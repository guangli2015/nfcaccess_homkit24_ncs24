From 9cabe3c6fe49ff3ea12116c5af002f18dbec56eb Mon Sep 17 00:00:00 2001
From: andrew li <andrew.li@nordicsemi.no>
Date: Mon, 30 Oct 2023 15:08:29 +0800
Subject: [PATCH] homekey NFC lock release

---
 CMakeLists.txt                                |   7 +-
 adk/PAL/nRF52/HAPPlatformNfcAccess.c          |  24 +-
 .../nrf52840dk_nrf52840.overlay               |  34 +
 samples/lock/CMakeLists.txt                   |   2 +
 samples/lock/prj.conf                         |  15 +
 samples/lock/prj_debug.conf                   |  32 +-
 samples/lock/src/app.c                        |  10 +
 samples/lock/src/tag_reader.c                 |  94 ++
 samples/lock/src/uaap_cmds.c                  | 913 ++++++++++++++++++
 9 files changed, 1126 insertions(+), 5 deletions(-)
 create mode 100644 samples/lock/src/tag_reader.c
 create mode 100644 samples/lock/src/uaap_cmds.c

diff --git a/CMakeLists.txt b/CMakeLists.txt
index c9b129e..345f5bd 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -82,6 +82,10 @@ if(CONFIG_HOMEKIT)
     target_compile_definitions(homekit_interface INTERFACE
       HAVE_NFC=1
       HAP_FEATURE_NFC=1
+      HAVE_NFC_ACCESS=1
+      HAP_FEATURE_NFC_ACCESS=1
+      HAVE_KEY_EXPORT=1
+      HAP_FEATURE_KEY_EXPORT=1
     )
   else()
     target_compile_definitions(homekit_interface INTERFACE
@@ -256,7 +260,7 @@ endif()
   FILE(GLOB app_generic_input adk/Applications/Common/Platform/AppUserInputGeneric.c)
   FILE(GLOB app_db adk/Applications/Common/DB/*.c)
   FILE(GLOB app_helper adk/Applications/Common/Helper/*.c)
-
+  FILE(GLOB adk_pal_nfc_access adk/PAL/nRF52/HAPPlatformNfcAccess.c)
   list(FILTER app_helper EXCLUDE REGEX .*/adk/Applications/Common/Helper/StandardInputHandler.c)
 
   
@@ -273,6 +277,7 @@ endif()
     ${app_generic_input}
     ${app_db}
     ${app_helper}
+    ${adk_pal_nfc_access}
   )
   
   zephyr_library_include_directories(${ZEPHYR_BASE}/subsys/bluetooth/host)
diff --git a/adk/PAL/nRF52/HAPPlatformNfcAccess.c b/adk/PAL/nRF52/HAPPlatformNfcAccess.c
index e4a8d27..3427b92 100644
--- a/adk/PAL/nRF52/HAPPlatformNfcAccess.c
+++ b/adk/PAL/nRF52/HAPPlatformNfcAccess.c
@@ -50,9 +50,20 @@
 #include "HAPCharacteristicTypes.h"
 #include "HAPCrypto.h"
 #include "HAPPlatform.h"
-
+#include <zephyr/logging/log.h>
+LOG_MODULE_DECLARE(st25r3916);//add by andrew
 #if HAP_FEATURE_ENABLED(HAP_FEATURE_NFC_ACCESS)
-
+//add by andrew
+#define PRINT_HEX(p_label, p_text, len)\
+	({\
+		LOG_INF("---- %s (len: %u): ----", p_label, len);\
+		LOG_HEXDUMP_INF(p_text, len, "Content:");\
+		LOG_INF("---- %s end  ----", p_label);\
+	})
+// add by andrew
+extern uint8_t reader_SK[NFC_ACCESS_READER_KEY_BYTES];
+extern uint8_t reader_group_id[NFC_ACCESS_KEY_IDENTIFIER_BYTES];
+extern void writeToFlash(void *data , size_t len);
 /**
  * The salt value used with a key value to create a hash for the Identifier field
  */
@@ -1289,6 +1300,15 @@ HAPError HAPPlatformNfcAccessReaderKeyAdd(
     }
 
     // VENDOR-TODO: Add reader key to the reader
+    // add by andrew
+    uint8_t temp[40];
+    
+     PRINT_HEX("reader_SKlan",readerKey->key,  readerKey->keyNumBytes);
+     PRINT_HEX("reader_group_id", identifier, NFC_ACCESS_KEY_IDENTIFIER_BYTES);
+     
+     HAPRawBufferCopyBytes(temp, identifier, NFC_ACCESS_KEY_IDENTIFIER_BYTES);
+     HAPRawBufferCopyBytes(temp+NFC_ACCESS_KEY_IDENTIFIER_BYTES, readerKey->key, readerKey->keyNumBytes);
+     writeToFlash(temp, 40);
 
     *statusCode = NFC_ACCESS_STATUS_CODE_SUCCESS;
     return kHAPError_None;
diff --git a/samples/common/configuration/nrf52840dk_nrf52840/nrf52840dk_nrf52840.overlay b/samples/common/configuration/nrf52840dk_nrf52840/nrf52840dk_nrf52840.overlay
index 0357cfa..994ba2f 100644
--- a/samples/common/configuration/nrf52840dk_nrf52840/nrf52840dk_nrf52840.overlay
+++ b/samples/common/configuration/nrf52840dk_nrf52840/nrf52840dk_nrf52840.overlay
@@ -11,6 +11,22 @@
 &pwm0 {
 	status = "disabled";
 };
+&spi0 {
+	compatible = "nordic,nrf-spi";
+	status = "okay";
+	cs-gpios = <&gpio1 12 GPIO_ACTIVE_LOW>;
+
+	pinctrl-0 = <&spi0_default_alt>;
+	pinctrl-1 = <&spi0_sleep_alt>;
+	pinctrl-names = "default", "sleep";
+	st25r3911b@0 {
+		compatible = "st,st25r3911b";
+		reg = <0>;
+		spi-max-frequency = <4000000>;
+		irq-gpios = <&gpio0 3 GPIO_ACTIVE_HIGH>;
+		led-nfca-gpios = <&gpio0 29 GPIO_ACTIVE_HIGH>;
+	};
+};
 &spi1 {
 	status = "disabled";
 };
@@ -20,3 +36,21 @@
 &usbd {
 	status = "disabled";
 };
+&pinctrl {
+	spi0_default_alt: spi0_default_alt {
+		group1 {
+			psels = <NRF_PSEL(SPIM_SCK, 1, 15)>,
+				<NRF_PSEL(SPIM_MOSI, 1, 13)>,
+				<NRF_PSEL(SPIM_MISO, 1, 14)>;
+		};
+	};
+
+	spi0_sleep_alt: spi0_sleep_alt {
+		group1 {
+			psels = <NRF_PSEL(SPIM_SCK, 1, 15)>,
+				<NRF_PSEL(SPIM_MOSI, 1, 13)>,
+				<NRF_PSEL(SPIM_MISO, 1, 14)>;
+			low-power-enable;
+		};
+	};
+};
diff --git a/samples/lock/CMakeLists.txt b/samples/lock/CMakeLists.txt
index cdcd7a4..6fd1bd4 100644
--- a/samples/lock/CMakeLists.txt
+++ b/samples/lock/CMakeLists.txt
@@ -45,6 +45,8 @@ find_package(Zephyr HINTS $ENV{ZEPHYR_BASE})
 project(homekit_lock)
 
 target_sources(app PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/src/app.c)
+target_sources(app PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/src/tag_reader.c)
+target_sources(app PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/src/uaap_cmds.c)
 target_sources(app PRIVATE ${COMMON_ROOT}/src/main.c)
 target_sources(app PRIVATE ${COMMON_ROOT}/src/hap.c)
 
diff --git a/samples/lock/prj.conf b/samples/lock/prj.conf
index 684d8b9..344411f 100644
--- a/samples/lock/prj.conf
+++ b/samples/lock/prj.conf
@@ -62,3 +62,18 @@ CONFIG_UART_CONSOLE=n
 
 # Stacks
 CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE=4492
+
+
+CONFIG_SPI=y
+
+CONFIG_ST25R3916_LIB=y
+CONFIG_POLL=y
+
+
+
+CONFIG_ST25R3916_LIB_LOG_LEVEL_INF=y
+CONFIG_LOG_DEFAULT_LEVEL=4
+
+
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_FLASH=y
\ No newline at end of file
diff --git a/samples/lock/prj_debug.conf b/samples/lock/prj_debug.conf
index 6994fc7..9217cd4 100644
--- a/samples/lock/prj_debug.conf
+++ b/samples/lock/prj_debug.conf
@@ -43,15 +43,19 @@ CONFIG_MCUBOOT_IMAGE_VERSION="1.0.0+0"
 CONFIG_BOOTLOADER_MCUBOOT=y
 
 # Miscellaneous
+CONFIG_MAIN_STACK_SIZE=4096
 CONFIG_MPU_STACK_GUARD=y
-CONFIG_HEAP_MEM_POOL_SIZE=1024
+CONFIG_HEAP_MEM_POOL_SIZE=4096
 CONFIG_ASSERT=n
 CONFIG_DK_LIBRARY=y
 CONFIG_REBOOT=y
 CONFIG_BOOT_BANNER=y
 
 # HomeKit Protocol
-CONFIG_HAP_LOG_LEVEL_DEBUG=y
+#CONFIG_HAP_LOG_LEVEL_DEBUG=y
+CONFIG_HAP_LOG_LEVEL_NONE=y
+#CONFIG_HAP_LOG_LEVEL_INFO=y
+#CONFIG_HAP_LOG_LEVEL_ERROR=y
 CONFIG_HAP_ASSERTS=y
 CONFIG_HAP_PRECONDITIONS=y
 CONFIG_HAP_LOG_MESSAGE_MAX_BYTES=512
@@ -84,3 +88,27 @@ CONFIG_RESET_ON_FATAL_ERROR=n
 
 # Stacks
 CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE=4492
+
+CONFIG_SPI=y
+
+CONFIG_ST25R3916_LIB=y
+CONFIG_POLL=y
+
+
+
+#CONFIG_ST25R3916_LIB_LOG_LEVEL_INF=y
+#CONFIG_LOG_DEFAULT_LEVEL=4
+
+# Enable nordic security backend and PSA APIs
+CONFIG_NRF_SECURITY=y
+CONFIG_MBEDTLS_PSA_CRYPTO_C=y
+
+CONFIG_MBEDTLS_ENABLE_HEAP=y
+CONFIG_MBEDTLS_HEAP_SIZE=8192
+
+# The Zephyr CMSIS emulation assumes that ticks are ms, currently
+CONFIG_SYS_CLOCK_TICKS_PER_SEC=1000
+
+
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_FLASH=y
\ No newline at end of file
diff --git a/samples/lock/src/app.c b/samples/lock/src/app.c
index fbcee27..a10deec 100644
--- a/samples/lock/src/app.c
+++ b/samples/lock/src/app.c
@@ -965,6 +965,16 @@ HAPError HandleLockMechanismLockTargetStateWrite(
     return kHAPError_None;
 }
 
+void LockStateChangebyNfc()
+{
+      uint8_t value;
+       value=1-accessoryConfiguration.state.currentState;
+       if (value) {
+        SetLockTargetState(kHAPCharacteristicValue_LockTargetState_Secured);
+    } else {
+        SetLockTargetState(kHAPCharacteristicValue_LockTargetState_Unsecured);
+    }
+}
 /**
  * Handle read request to the 'Battery Level' characteristic of the Battery service.
  */
diff --git a/samples/lock/src/tag_reader.c b/samples/lock/src/tag_reader.c
new file mode 100644
index 0000000..f238f26
--- /dev/null
+++ b/samples/lock/src/tag_reader.c
@@ -0,0 +1,94 @@
+/* main.c - Application main entry point */
+
+/*
+ * Copyright (c) 2019 Nordic Semiconductor ASA
+ *
+ * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
+ */
+
+#include <zephyr/types.h>
+#include <stddef.h>
+#include <stdbool.h>
+#include <string.h>
+#include <zephyr/kernel.h>
+#include <zephyr/sys/printk.h>
+//#include <st25r3911b_nfca.h>
+#include <nfc/ndef/msg_parser.h>
+#include <nfc/ndef/le_oob_rec_parser.h>
+#include <nfc/t2t/parser.h>
+#include <nfc/t4t/ndef_file.h>
+#include <nfc/t4t/isodep.h>
+#include <nfc/t4t/hl_procedure.h>
+#include <nfc/ndef/ch_rec_parser.h>
+#include <zephyr/sys/byteorder.h>
+#include <st25r3916_nfca.h>
+
+#include "st25r3916_irq.h"
+#include "rfal_nfc.h"
+#include "demo.h"
+
+#define MY_STACK_SIZE 1024
+#define MY_PRIORITY -2
+static K_SEM_DEFINE(irq_sem, 0, 1);
+//static K_SEM_DEFINE(rfal_sem, 0, 1);
+int is=0;
+
+extern void flash_setup();
+
+void my_entry_point(int unused1, int unused2, int unused3)
+{
+	int err;
+	while(1){
+		err = k_sem_take(&irq_sem, K_FOREVER);
+		if (err) {
+			return;
+		}
+                
+		st25r3916Isr();
+               // k_sem_give(&rfal_sem);
+                //printk("&");
+
+	}
+
+}
+
+K_THREAD_STACK_DEFINE(my_stack_area, MY_STACK_SIZE);
+
+ //K_SEM_DEFINE(debug_sem, 0, 1);
+
+void tag_reader(int unused1, int unused2, int unused3)
+{
+	int err;
+    printk("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
+#if 1
+	st25r3916InitInterrupts(&irq_sem);
+	struct k_thread my_thread_data;
+	
+	k_tid_t my_tid = k_thread_create(&my_thread_data, my_stack_area,
+									 K_THREAD_STACK_SIZEOF(my_stack_area),
+									 my_entry_point,
+									 NULL, NULL, NULL,
+									 MY_PRIORITY, 0, K_NO_WAIT);
+
+	err = st25r3916_nfca_init();
+	if (err) {
+		return err;
+	}
+    
+	flash_setup();
+	
+#if 1
+if(demoIni())
+{
+        printk("init ok\n");
+         while(1)
+        {
+                demoCycle();
+
+                k_sleep(K_MSEC(30));
+        }
+}
+#endif
+#endif
+}
+K_THREAD_DEFINE(tag, 4096, tag_reader, NULL, NULL, NULL, 5, 0, 0);
diff --git a/samples/lock/src/uaap_cmds.c b/samples/lock/src/uaap_cmds.c
new file mode 100644
index 0000000..aade6fd
--- /dev/null
+++ b/samples/lock/src/uaap_cmds.c
@@ -0,0 +1,913 @@
+/******************************************************************************
+  * @attention
+  *
+  * COPYRIGHT 2019 STMicroelectronics, all rights reserved
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied,
+  * AND SPECIFICALLY DISCLAIMING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
+  * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+******************************************************************************/
+
+
+/*! \file
+ *
+ *  \author 
+ *
+ *  \brief Demo application
+ *
+ *  This demo shows how to poll for several types of NFC cards/devices and how 
+ *  to exchange data with these devices, using the RFAL library.
+ *
+ *  This demo does not fully implement the activities according to the standards,
+ *  it performs the required to communicate with a card/device and retrieve 
+ *  its UID. Also blocking methods are used for data exchange which may lead to
+ *  long periods of blocking CPU/MCU.
+ *  For standard compliant example please refer to the Examples provided
+ *  with the RFAL library.
+ * 
+ */
+ 
+/*
+ ******************************************************************************
+ * INCLUDES
+ ******************************************************************************
+ */
+#include <stdio.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <stdarg.h>
+#include <zephyr/kernel.h>
+#include <stdbool.h>
+#include <assert.h>
+#include <zephyr/sys/util.h>
+#include <zephyr/sys/byteorder.h>
+#include <string.h>
+#include <zephyr/logging/log.h>
+#include "demo.h"
+#include "utils.h"
+#include "rfal_nfc.h"
+#include "logger.h"
+#include <psa/crypto.h>
+#include <psa/crypto_extra.h>
+
+#define SPI_FLASH_TEST_REGION_OFFSET 0xff000
+
+#define SPI_FLASH_SECTOR_SIZE        4096
+LOG_MODULE_DECLARE(st25r3916);
+
+#define platformLog LOG_INF
+/*
+******************************************************************************
+* GLOBAL DEFINES
+******************************************************************************
+*/
+
+
+
+/*
+ ******************************************************************************
+ * GLOBAL MACROS
+ ******************************************************************************
+ */
+#ifdef UAAP_DEBUG
+#define PRINT_HEX(p_label, p_text, len)\
+	({\
+		LOG_INF("---- %s (len: %u): ----", p_label, len);\
+		LOG_HEXDUMP_INF(p_text, len, "Content:");\
+		LOG_INF("---- %s end  ----", p_label);\
+	})
+#else
+#define PRINT_HEX(p_label, p_text, len)
+#endif
+/*
+ ******************************************************************************
+ * LOCAL VARIABLES
+ ******************************************************************************
+ */                                 
+/* VASUP-A Command: TCI must be set according to data received via MFi Program  */
+static uint8_t demoEcpVasup[] = { 0x6A,    /* VASUP-A Command             */
+                                  0x02,    /* Byte1  - Format: 2.0        */
+                                  0xCB,    /* Byte2  - Terminal Info      */
+                                  0x02,    /* Byte3  - Terminal Type      */
+                                  0x04,    /* Byte4  - Terminal Subtype   */
+                                  0x02,    /* Byte5  - TCI 1              */
+                                  0x11,    /* Byte6  - TCI 2              */
+                                  0x00,    /* Byte7  - TCI 3              */
+                                  0xb0,0x2a,0x52,0x74,0xec,0x02,0x13,0x4d,  /* Reader Identifier */
+};
+static uint8_t expTransacSelectApp[] = { 0x00, 0xA4, 0x04, 0x00, 0x0c, 0xA0, 0x00, 0x00, 0x08, 0x58, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00};
+
+
+static uint8_t reader_group_head[]={0x4d,0x10};
+
+uint8_t reader_group_id[8]={0};
+static uint8_t reader_group_sub_id[8];
+
+static uint8_t transaction_id_head[]={0x4c,0x10};
+static uint8_t transaction_id[16];
+static uint8_t auth1_usage[]={0x93,0x04,0x41,0x5d,0x95,0x69};
+
+static uint8_t reader_ePK[65];
+static uint8_t endp_ePK[65];
+static uint8_t m_signature[64];
+static uint8_t m_hash[32];
+static uint8_t datafield[110];//plain text for sign auth1
+static psa_key_handle_t keypair_handle;
+static psa_key_handle_t auth1_keypair_handle;
+static psa_key_handle_t ecdh_keypair_handle;
+static psa_key_handle_t hkdf_in_keypair_handle;
+static psa_key_handle_t hkdf_out_keypair_handle;
+static psa_key_handle_t aes_keypair_handle;
+static psa_key_handle_t endp_pub_key_handle;
+uint8_t reader_SK[32]={0};
+static uint8_t reader_eSK[32]={0};
+
+static uint8_t endp_pub_key[65];
+
+
+
+
+static int import_ecdsa_prv_key(void);
+static int create_ecdh_keypair(psa_key_handle_t *key_handle);
+static int calculate_ecdh_secret(psa_key_handle_t *key_handle,
+			  uint8_t *pub_key,
+			  size_t pub_key_len,
+			  uint8_t *secret,
+			  size_t secret_len);
+static int import_hkdf_input_key(uint8_t *kdh);
+static int derive_hkdf(size_t out_key_size,uint8_t * m_ainfo , size_t info_len);
+static int aes_import_key(uint8_t * kenc);
+static int decrypt_cbc_aes(uint8_t * m_encrypted_text,size_t en_size,uint8_t *m_decrypted_text ,size_t de_size,uint8_t * m_iv);
+static int import_ecdsa_pub_key(void);
+static int verify_endp_message(uint8_t *endp_sig,size_t sig_size);
+static int encrypt_cbc_aes(uint8_t * m_encrypted_text,size_t en_size,uint8_t *m_plain_text ,size_t pl_size,uint8_t * m_iv);
+
+extern void read_from_flash(uint8_t *tmp, size_t size);
+
+static int crypto_finish(void)
+{
+	psa_status_t status;
+
+	/* Destroy the key handle */
+	status = psa_destroy_key(keypair_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_destroy_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+	status = psa_destroy_key(auth1_keypair_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_destroy_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+    status = psa_destroy_key(ecdh_keypair_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_destroy_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+    status = psa_destroy_key(hkdf_in_keypair_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_destroy_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+    status = psa_destroy_key(hkdf_out_keypair_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_destroy_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+    status = psa_destroy_key(aes_keypair_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_destroy_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+     status = psa_destroy_key(endp_pub_key_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_destroy_key failed! (Error: %d)", status);
+		return -1;
+	}
+	return 0;
+}
+static int generate_ephem_keypair(void)
+{
+	psa_status_t status;
+	size_t olen;
+
+	LOG_INF("Generating random ECDSA keypair...");
+
+	/* Configure the key attributes */
+	psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
+
+	/* Configure the key attributes */
+	psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_SIGN_HASH | PSA_KEY_USAGE_EXPORT);
+	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
+	psa_set_key_algorithm(&key_attributes, PSA_ALG_ECDSA(PSA_ALG_SHA_256));
+	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_FAMILY_SECP_R1));
+	psa_set_key_bits(&key_attributes, 256);
+
+	/* Generate a random keypair. The keypair is not exposed to the application,
+	 * we can use it to signing/verification the key handle.
+	 */
+	status = psa_generate_key(&key_attributes, &keypair_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_generate_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Export the public key */
+	status = psa_export_public_key(keypair_handle, reader_ePK, sizeof(reader_ePK), &olen);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_export_public_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+    //PRINT_HEX("reader_ePK", reader_ePK, 65);
+    status = psa_export_key(keypair_handle, reader_eSK, sizeof(reader_eSK), &olen);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_export_prv_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+    //PRINT_HEX("reader_eSK", reader_eSK, 32);
+	/* After the key handle is acquired the attributes are not needed */
+	psa_reset_key_attributes(&key_attributes);
+
+
+	return 0;
+}
+
+
+int sign_message(void)
+{
+	uint32_t output_len;
+	psa_status_t status;
+
+	LOG_INF("Signing a message using ECDSA...");
+
+	/* Compute the SHA256 hash*/
+	status = psa_hash_compute(PSA_ALG_SHA_256,
+				  datafield,
+				  sizeof(datafield),
+				  m_hash,
+				  sizeof(m_hash),
+				  &output_len);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_hash_compute failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Sign the hash */
+	status = psa_sign_hash(auth1_keypair_handle,
+			       PSA_ALG_ECDSA(PSA_ALG_SHA_256),
+			       m_hash,
+			       sizeof(m_hash),
+			       m_signature,
+			       sizeof(m_signature),
+			       &output_len);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_sign_hash failed! (Error: %d)", status);
+		return -1;
+	}
+
+	LOG_INF("Signing the message successful!");
+    
+	return 0;
+}
+
+//static uint8_t m_pub_key[65];//for test
+static int import_ecdsa_prv_key(void)
+{
+	/* Configure the key attributes */
+	psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
+	psa_status_t status;
+	/* Configure the key attributes */
+	psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_SIGN_HASH | PSA_KEY_USAGE_VERIFY_HASH);
+	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
+	psa_set_key_algorithm(&key_attributes, PSA_ALG_ECDSA(PSA_ALG_SHA_256));
+	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_FAMILY_SECP_R1));
+	//psa_set_key_bits(&key_attributes, 256);
+    PRINT_HEX("reader_SKecdsa", reader_SK, 32);
+	status = psa_import_key(&key_attributes, reader_SK, sizeof(reader_SK), &auth1_keypair_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_import_key failed! (Error: %d)", status);
+		return -1;
+	}
+    size_t olen;
+
+	/* After the key handle is acquired the attributes are not needed */
+	psa_reset_key_attributes(&key_attributes);
+
+	return 0;
+}
+
+static int create_ecdh_keypair(psa_key_handle_t *key_handle)
+{
+	psa_status_t status;
+	psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
+
+	/* Crypto settings for ECDH using the SHA256 hashing algorithm,
+	 * the secp256r1 curve
+	 */
+	psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_DERIVE);
+	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
+	psa_set_key_algorithm(&key_attributes, PSA_ALG_ECDH);
+	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_FAMILY_SECP_R1));
+	psa_set_key_bits(&key_attributes, 256);
+
+	status = psa_import_key(&key_attributes,reader_eSK,sizeof(reader_eSK), key_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_generate_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+	psa_reset_key_attributes(&key_attributes);
+
+	LOG_INF("ECDH keypair import successfully!");
+
+	return 0;
+}
+
+static int calculate_ecdh_secret(psa_key_handle_t *key_handle,
+			  uint8_t *pub_key,
+			  size_t pub_key_len,
+			  uint8_t *secret,
+			  size_t secret_len)
+{
+	uint32_t output_len;
+	psa_status_t status;
+
+	/* Perform the ECDH key exchange to calculate the secret */
+	status = psa_raw_key_agreement(
+		PSA_ALG_ECDH, *key_handle, pub_key, pub_key_len, secret, secret_len, &output_len);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_raw_key_agreement failed! (Error: %d)", status);
+		return -1;
+	}
+
+	LOG_INF("ECDH secret calculated successfully!");
+
+	return 0;
+}
+
+static int import_hkdf_input_key(uint8_t *kdh)
+{
+	psa_status_t status;
+	psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
+
+	/* Configure the input key attributes */
+	psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_DERIVE);
+	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
+	psa_set_key_algorithm(&key_attributes, PSA_ALG_HKDF(PSA_ALG_SHA_256));
+	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_DERIVE);
+	psa_set_key_bits(&key_attributes,
+			 32 * 8);
+    //PRINT_HEX("kdhhkdf", kdh, 32);
+	/* Import the master key into the keystore */
+	status = psa_import_key(&key_attributes,
+				kdh,
+				32,
+				&hkdf_in_keypair_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_import_key failed! (Error: %d)", status);
+		return -1;
+	}
+LOG_INF("import_hkdf_input_key successfully!");
+	return 0;
+}
+
+static int derive_hkdf(size_t out_key_size,uint8_t * m_ainfo , size_t info_len)
+{
+	psa_status_t status;
+	psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
+	psa_key_derivation_operation_t operation =
+		PSA_KEY_DERIVATION_OPERATION_INIT;
+
+	LOG_INF("Deriving a key using HKDF and SHA256...");
+
+	/* Derived key settings
+	 * WARNING: This key usage makes the key exportable which is not safe and
+	 * is only done to demonstrate the validity of the results. Please do not use
+	 * this in production environments.
+	 */
+	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
+	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_RAW_DATA);
+	psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_EXPORT); /* DONT USE IN PRODUCTION */
+	psa_set_key_bits(&key_attributes, out_key_size * 8);
+
+	/* Set the derivation algorithm */
+	status = psa_key_derivation_setup(&operation,
+					  PSA_ALG_HKDF(PSA_ALG_SHA_256));
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_key_derivation_setup failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Set the master key for the operation */
+	status = psa_key_derivation_input_key(
+		&operation, PSA_KEY_DERIVATION_INPUT_SECRET, hkdf_in_keypair_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_key_derivation_input_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+    //PRINT_HEX("m_ainfo", m_ainfo, info_len);
+	/* Set the additional info for the operation */
+	status = psa_key_derivation_input_bytes(&operation,
+						PSA_KEY_DERIVATION_INPUT_INFO,
+						m_ainfo,
+						info_len);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_key_derivation_input_bytes failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Store the derived key in the keystore slot pointed by out_key_handle */
+	status = psa_key_derivation_output_key(&key_attributes, &operation, &hkdf_out_keypair_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_key_derivation_output_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Clean up the context */
+	status = psa_key_derivation_abort(&operation);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_key_derivation_abort failed! (Error: %d)", status);
+		return -1;
+	}
+
+	LOG_INF("Key derivation successful!");
+
+	return 0;
+}
+
+
+static int aes_import_key(uint8_t * kenc)
+{
+	psa_status_t status;
+
+	LOG_INF("Generating random AES key...");
+
+	/* Configure the key attributes */
+	psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
+
+	psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_ENCRYPT | PSA_KEY_USAGE_DECRYPT);
+	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
+	psa_set_key_algorithm(&key_attributes, PSA_ALG_CBC_NO_PADDING);
+	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_AES);
+	psa_set_key_bits(&key_attributes, 128);
+
+	/* Generate a random key. The key is not exposed to the application,
+	 * we can use it to encrypt/decrypt using the key handle
+	 */
+	//status = psa_generate_key(&key_attributes, &key_handle);
+	status = psa_import_key(&key_attributes, kenc, 16, &aes_keypair_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_generate_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* After the key handle is acquired the attributes are not needed */
+	psa_reset_key_attributes(&key_attributes);
+
+	LOG_INF("AES key generated successfully!");
+
+	return 0;
+}
+
+static int decrypt_cbc_aes(uint8_t * m_encrypted_text,size_t en_size,uint8_t *m_decrypted_text ,size_t de_size,uint8_t * m_iv)
+{
+	uint32_t olen;
+	psa_status_t status;
+	psa_cipher_operation_t operation = PSA_CIPHER_OPERATION_INIT;
+
+	LOG_INF("Decrypting using AES CBC MODE...");
+
+	/* Setup the decryption operation */
+	status = psa_cipher_decrypt_setup(&operation, aes_keypair_handle, PSA_ALG_CBC_NO_PADDING);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_cipher_decrypt_setup failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Set the IV generated in encryption */
+	status = psa_cipher_set_iv(&operation, m_iv, 16);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_cipher_set_iv failed! (Error: %d)", status);
+		return -1;
+	}
+//PRINT_HEX("Encrypted text", m_encrypted_text, en_size);
+	/* Perform the decryption */
+	status = psa_cipher_update(&operation, m_encrypted_text,
+				  en_size, m_decrypted_text,
+				   de_size, &olen);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_cipher_update failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Finalize the decryption */
+	status = psa_cipher_finish(&operation, m_decrypted_text + olen,
+				   de_size - olen,
+				   &olen);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_cipher_finish failed! (Error: %d)", status);
+		return -1;
+	}
+
+	PRINT_HEX("Decrypted text", m_decrypted_text, de_size);
+
+	LOG_INF("Decryption successful!");
+
+	/*  Clean up cipher operation context */
+	psa_cipher_abort(&operation);
+
+	return 0;
+}
+
+static int encrypt_cbc_aes(uint8_t * m_encrypted_text,size_t en_size,uint8_t *m_plain_text ,size_t pl_size,uint8_t * m_iv)
+{
+	uint32_t olen;
+	psa_status_t status;
+	psa_cipher_operation_t operation = PSA_CIPHER_OPERATION_INIT;
+
+	LOG_INF("Encrypting using AES CBC MODE...");
+
+	/* Setup the encryption operation */
+	status = psa_cipher_encrypt_setup(&operation, aes_keypair_handle, PSA_ALG_CBC_NO_PADDING);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_cipher_encrypt_setup failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Generate an IV */
+	//status = psa_cipher_generate_iv(&operation, m_iv, sizeof(m_iv), &olen);
+	status = psa_cipher_set_iv(&operation, m_iv, 16);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_cipher_generate_iv failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Perform the encryption */
+	status = psa_cipher_update(&operation, m_plain_text,
+				   pl_size, m_encrypted_text,
+				   en_size, &olen);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_cipher_update failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Finalize the encryption */
+	status = psa_cipher_finish(&operation, m_encrypted_text + olen,
+				   en_size - olen,
+				   &olen);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_cipher_finish failed! (Error: %d)", status);
+		return -1;
+	}
+
+	LOG_INF("Encryption successful!");
+	/*PRINT_HEX("IV", m_iv, sizeof(m_iv));
+	PRINT_HEX("Plaintext", m_plain_text, sizeof(m_plain_text));
+	PRINT_HEX("Encrypted text", m_encrypted_text, sizeof(m_encrypted_text));*/
+
+	/* Clean up cipher operation context */
+	psa_cipher_abort(&operation);
+
+	return 0;
+}
+
+static int import_ecdsa_pub_key(void)
+{
+	/* Configure the key attributes */
+	psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
+	psa_status_t status;
+	/* Configure the key attributes */
+	psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_VERIFY_HASH);
+	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
+	psa_set_key_algorithm(&key_attributes, PSA_ALG_ECDSA(PSA_ALG_SHA_256));
+	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_ECC_PUBLIC_KEY(PSA_ECC_FAMILY_SECP_R1));
+	//psa_set_key_bits(&key_attributes, 256);
+    PRINT_HEX("endp_pub_key", endp_pub_key, sizeof(endp_pub_key));
+	status = psa_import_key(&key_attributes, endp_pub_key, sizeof(endp_pub_key), &endp_pub_key_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_import_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* After the key handle is acquired the attributes are not needed */
+	psa_reset_key_attributes(&key_attributes);
+
+	return 0;
+}
+static int verify_endp_message(uint8_t *endp_sig,size_t sig_size)
+{
+	uint32_t output_len;
+	psa_status_t status;
+
+	LOG_INF("Verifying endp ECDSA signature...");
+
+	/* Compute the SHA256 hash*/
+	status = psa_hash_compute(PSA_ALG_SHA_256,
+				  datafield,
+				  sizeof(datafield),
+				  m_hash,
+				  sizeof(m_hash),
+				  &output_len);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_hash_compute failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Sign the hash */
+	status = psa_verify_hash(endp_pub_key_handle,
+			       PSA_ALG_ECDSA(PSA_ALG_SHA_256),
+			       m_hash,
+			       sizeof(m_hash),
+			       endp_sig,
+			       sig_size);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_sign_hash failed! (Error: %d)", status);
+		return -1;
+	}
+
+	LOG_INF("Verifying the message successful!");
+    
+	return 0;
+}
+int Make_AUTH0_cmd()
+{
+    psa_status_t status;
+    uint8_t auth0_head[]={0x80,0x80,0x01,0x01,0x6b,0x5c,0x02,0x02,0x00};
+    uint8_t reader_ePK_head[]={0x87,0x41};
+
+
+    uint8_t auth0_end[]={0x00};
+    uint8_t auth0_data[113]={0};
+
+    ReturnCode err;
+    uint16_t   *rxLen;
+    uint8_t    *rxData;
+    int rc;
+    uint8_t temp[40];
+    LOG_INF("AUTH0_make start...\n");
+    read_from_flash(temp,40);
+    memcpy(reader_group_id,temp,sizeof(reader_group_id));
+    memcpy(reader_SK,temp+sizeof(reader_group_id),sizeof(reader_SK));
+	PRINT_HEX("reader_SK",reader_SK, 32);
+    PRINT_HEX("r_g_id", reader_group_id, 8);
+   	/* Initialize PSA Crypto */
+	status = psa_crypto_init();
+	if (status != PSA_SUCCESS)
+		{
+            LOG_INF("psa_crypto_init failed!\n");
+            return ;
+        }
+
+    status = generate_ephem_keypair();
+	if (status != 0) {
+		LOG_INF("generate_ecdsa_keypair fail");
+		return ;
+	}
+    status = psa_generate_random(transaction_id, sizeof(transaction_id));
+		if (status != PSA_SUCCESS) {
+			LOG_INF("psa_generate_random failed! (Error: %d)", status);
+			return ;
+		}
+    status = psa_generate_random(reader_group_sub_id, sizeof(reader_group_sub_id));
+		if (status != PSA_SUCCESS) {
+			LOG_INF("psa_generate_random failed! (Error: %d)", status);
+			return ;
+		}
+
+   // PRINT_HEX("transaction_id", transaction_id, 16);
+   // PRINT_HEX("reader_group_sub_id", reader_group_sub_id, 8);
+    memcpy(auth0_data,auth0_head,sizeof(auth0_head));
+    memcpy(auth0_data+sizeof(auth0_head),reader_ePK_head,sizeof(reader_ePK_head));
+    memcpy(auth0_data+sizeof(auth0_head)+sizeof(reader_ePK_head),reader_ePK,sizeof(reader_ePK));
+    memcpy(auth0_data+sizeof(auth0_head)+sizeof(reader_ePK_head)+sizeof(reader_ePK),transaction_id_head,sizeof(transaction_id_head));
+    memcpy(auth0_data+sizeof(auth0_head)+sizeof(reader_ePK_head)+sizeof(reader_ePK)+sizeof(transaction_id_head),transaction_id,sizeof(transaction_id));
+    memcpy(auth0_data+sizeof(auth0_head)+sizeof(reader_ePK_head)+sizeof(reader_ePK)+sizeof(transaction_id_head)+sizeof(transaction_id),reader_group_head,sizeof(reader_group_head));
+    memcpy(auth0_data+sizeof(auth0_head)+sizeof(reader_ePK_head)+sizeof(reader_ePK)+sizeof(transaction_id_head)+sizeof(transaction_id)+sizeof(reader_group_head),reader_group_id,sizeof(reader_group_id));
+    memcpy(auth0_data+sizeof(auth0_head)+sizeof(reader_ePK_head)+sizeof(reader_ePK)+sizeof(transaction_id_head)+sizeof(transaction_id)+sizeof(reader_group_head)+sizeof(reader_group_id),reader_group_sub_id,sizeof(reader_group_sub_id));
+    memcpy(auth0_data+sizeof(auth0_head)+sizeof(reader_ePK_head)+sizeof(reader_ePK)+sizeof(transaction_id_head)+sizeof(transaction_id)+sizeof(reader_group_head)+sizeof(reader_group_id)+sizeof(reader_group_sub_id),auth0_end,sizeof(auth0_end));
+
+    /* Exchange APDU: Unified Access APDUs */
+    err = demoTransceiveBlocking( auth0_data, sizeof(auth0_data), &rxData, &rxLen, RFAL_FWT_NONE );
+    if( (err == ERR_NONE) && (*rxLen > 2) && rxData[*rxLen-2] == 0x90 && rxData[*rxLen-1] == 0x00)
+    {
+        /* Here more APDUs to implement the protocol are required. */
+
+        if(*rxLen>67)
+        {
+            memcpy(endp_ePK,rxData+2,65);
+        }
+        return 0;
+    }
+    else
+    {
+        return -1;
+    }
+
+    return;
+}
+
+
+void Make_AUTH1_cmd()
+{
+    uint8_t auth1_head[]={0x80,0x81,0x01,0x00,0x42};
+    uint8_t reader_sig_head[]={0x9e,0x40};
+    uint8_t auth1_end[]={0x00};
+    uint8_t   auth1_cmd[72];
+    uint8_t endp_ePKX_h[]={0x86,0x20};
+    uint8_t reader_ePKX_h[]={0x87,0x20};
+    uint8_t usage[]={0x93,0x04,0x41,0x5d,0x95,0x69};
+    ReturnCode err;
+    uint16_t   *rxLen;
+    uint8_t    *rxData;
+    memcpy(datafield,reader_group_head,sizeof(reader_group_head));
+    memcpy(datafield+sizeof(reader_group_head),reader_group_id,sizeof(reader_group_id));
+    memcpy(datafield+sizeof(reader_group_head)+sizeof(reader_group_id),reader_group_sub_id,sizeof(reader_group_sub_id));
+    memcpy(datafield+sizeof(reader_group_head)+sizeof(reader_group_id)+sizeof(reader_group_sub_id),endp_ePKX_h,sizeof(endp_ePKX_h));
+    memcpy(datafield+sizeof(reader_group_head)+sizeof(reader_group_id)+sizeof(reader_group_sub_id)+sizeof(endp_ePKX_h),endp_ePK+1,32);
+    memcpy(datafield+sizeof(reader_group_head)+sizeof(reader_group_id)+sizeof(reader_group_sub_id)+sizeof(endp_ePKX_h)+32,reader_ePKX_h,sizeof(reader_ePKX_h));
+    memcpy(datafield+sizeof(reader_group_head)+sizeof(reader_group_id)+sizeof(reader_group_sub_id)+sizeof(endp_ePKX_h)+32+sizeof(reader_ePKX_h),reader_ePK+1,32);
+    memcpy(datafield+sizeof(reader_group_head)+sizeof(reader_group_id)+sizeof(reader_group_sub_id)+sizeof(endp_ePKX_h)+32+sizeof(reader_ePKX_h)+32,transaction_id_head,sizeof(transaction_id_head));
+    memcpy(datafield+sizeof(reader_group_head)+sizeof(reader_group_id)+sizeof(reader_group_sub_id)+sizeof(endp_ePKX_h)+32+sizeof(reader_ePKX_h)+32+sizeof(transaction_id_head),transaction_id,sizeof(transaction_id));
+    memcpy(datafield+sizeof(reader_group_head)+sizeof(reader_group_id)+sizeof(reader_group_sub_id)+sizeof(endp_ePKX_h)+32+sizeof(reader_ePKX_h)+32+sizeof(transaction_id_head)+sizeof(transaction_id),usage,sizeof(usage));
+ 
+    import_ecdsa_prv_key();
+    sign_message();
+
+    memcpy(auth1_cmd,auth1_head,sizeof(auth1_head));
+    memcpy(auth1_cmd+sizeof(auth1_head),reader_sig_head,sizeof(reader_sig_head));
+    memcpy(auth1_cmd+sizeof(auth1_head)+sizeof(reader_sig_head),m_signature,sizeof(m_signature));
+    memcpy(auth1_cmd+sizeof(auth1_head)+sizeof(reader_sig_head)+sizeof(m_signature),auth1_end,sizeof(auth1_end));
+
+    err = demoTransceiveBlocking( auth1_cmd, sizeof(auth1_cmd), &rxData, &rxLen, RFAL_FWT_NONE );
+    if( (err == ERR_NONE) && (*rxLen > 2) && rxData[*rxLen-2] == 0x90 && rxData[*rxLen-1] == 0x00)
+    {
+        /* Here more APDUs to implement the protocol are required. */
+        PRINT_HEX("au1Re", rxData, *rxLen);
+
+    }
+    else 
+    {   
+         PRINT_HEX("au1ReE", rxData, *rxLen);
+    }
+
+     uint8_t s_secret[32]={0};
+    create_ecdh_keypair(&ecdh_keypair_handle);
+
+    calculate_ecdh_secret(&ecdh_keypair_handle,
+				       endp_ePK,
+				       sizeof(endp_ePK),
+				       s_secret,
+				       sizeof(s_secret));
+
+    uint8_t kdh_input[32+4+16];
+    uint8_t tmp[4]={0x00,0x00,0x00,0x01};
+    memcpy(kdh_input,s_secret,sizeof(s_secret));
+    memcpy(kdh_input+sizeof(s_secret),tmp,sizeof(tmp));
+    memcpy(kdh_input+sizeof(s_secret)+sizeof(tmp),transaction_id,sizeof(transaction_id));
+
+    uint32_t output_len;
+	psa_status_t status;
+    uint8_t d_kdh[32];
+	/* Compute the SHA256 hash*/
+	status = psa_hash_compute(PSA_ALG_SHA_256,
+				  kdh_input,
+				  sizeof(kdh_input),
+				  d_kdh,
+				  sizeof(d_kdh),
+				  &output_len);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_hash_compute failed! (Error: %d)", status);
+	}
+
+    uint8_t hkdf_output_key48[48];
+    uint8_t auth1_hkdf_info_48[101];
+    uint8_t interface_to_end_48[]={0x5E ,0x01 ,0x01 ,0x56 ,0x6F ,0x6C ,0x61 ,0x74 ,0x69 ,0x6C ,0x65 ,0x5C ,0x02 ,0x02 ,0x00 ,0x5C ,0x04 ,0x02 ,0x00 ,0x01 ,0x00 };
+    memcpy(auth1_hkdf_info_48,reader_ePK+1,32);
+    memcpy(auth1_hkdf_info_48+32,endp_ePK+1,32);
+    memcpy(auth1_hkdf_info_48+32+32,transaction_id,sizeof(transaction_id));
+    memcpy(auth1_hkdf_info_48+32+32+sizeof(transaction_id),interface_to_end_48,sizeof(interface_to_end_48));
+
+    import_hkdf_input_key(d_kdh);
+    //PRINT_HEX("auth1_hkdf_info_48", auth1_hkdf_info_48, sizeof(auth1_hkdf_info_48));
+    derive_hkdf(48,auth1_hkdf_info_48,sizeof(auth1_hkdf_info_48));
+
+    size_t olen;
+    /* Export the generated key content to verify it's value */
+	status = psa_export_key(hkdf_out_keypair_handle, hkdf_output_key48, sizeof(hkdf_output_key48), &olen);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_export_key failed! (Error: %d)", status);
+		
+	}
+    //PRINT_HEX("key48", hkdf_output_key48, sizeof(hkdf_output_key48));
+    uint8_t kPersistent[32];
+    uint8_t auth1_hkdf_info_32[103];
+    uint8_t interface_to_end_32[]={0x5E ,0x01 ,0x01 ,0x50 ,0x65 ,0x72 ,0x73 ,0x69 ,0x73 ,0x74 ,0x65 , 0x6e ,0x74 ,0x5C ,0x02 ,0x02 ,0x00 ,0x5C ,0x04 ,0x02 ,0x00 ,0x01 ,0x00 };
+    memcpy(auth1_hkdf_info_32,reader_ePK+1,32);
+    memcpy(auth1_hkdf_info_32+32,endp_ePK+1,32);
+    memcpy(auth1_hkdf_info_32+32+32,transaction_id,sizeof(transaction_id));
+    memcpy(auth1_hkdf_info_32+32+32+sizeof(transaction_id),interface_to_end_32,sizeof(interface_to_end_32));
+    derive_hkdf(32,auth1_hkdf_info_32,sizeof(auth1_hkdf_info_32));
+     /* Export the generated key content to verify it's value*/
+	status = psa_export_key(hkdf_out_keypair_handle, kPersistent, sizeof(kPersistent), &olen);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_export_key failed! (Error: %d)", status);
+		
+	} 
+    uint8_t iv_for_miv[16]={0};
+    uint8_t append_text[]={0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
+    uint8_t m_iv[16];
+    uint8_t m_decrypted_text[144]={0};
+    aes_import_key(hkdf_output_key48);
+    encrypt_cbc_aes(m_iv,sizeof(m_iv),append_text,sizeof(append_text),iv_for_miv);
+    decrypt_cbc_aes(rxData,(*rxLen)-10,m_decrypted_text ,(*rxLen)-10,m_iv);
+    memcpy(endp_pub_key,m_decrypted_text+2,65);
+ 
+    uint8_t endp_usage[]={0x93,0x04,0x4e,0x88,0x7b,0x4c};
+    memcpy(datafield+sizeof(reader_group_head)+sizeof(reader_group_id)+sizeof(reader_group_sub_id)+sizeof(endp_ePKX_h)+32+sizeof(reader_ePKX_h)+32+sizeof(transaction_id_head)+sizeof(transaction_id),endp_usage,sizeof(endp_usage));
+    
+    import_ecdsa_pub_key();
+    if(0==verify_endp_message(m_decrypted_text+69,64))
+    {
+        LockStateChangebyNfc();
+    }
+
+    crypto_finish();
+
+}   
+
+void Make_control_flow_cmd()
+{
+    psa_status_t status;
+    uint8_t control_flow_cmd[]={0x80,0x3c,0x01,0x00};
+    uint16_t   *rxLen;
+    uint8_t    *rxData;
+    ReturnCode err;
+     /* Exchange APDU: Unified Access APDUs */
+    err = demoTransceiveBlocking( control_flow_cmd, sizeof(control_flow_cmd), &rxData, &rxLen, RFAL_FWT_NONE );
+    if( (err == ERR_NONE)  && rxData[*rxLen-2] == 0x90 && rxData[*rxLen-1] == 0x00)
+    {
+        /* Here more APDUs to implement the protocol are required. */
+        LOG_INF("transaction sucess\n");
+
+    }else
+    {
+         LOG_INF("transaction fail\n");
+    }
+}
+
+void Make_ECPVASUP_cmd(uint8_t *data,size_t size)
+{
+    memcpy(data,demoEcpVasup,size);
+}
+
+int make_select_cmd()
+{
+     ReturnCode err;
+    uint16_t   *rxLen;
+    uint8_t    *rxData;
+
+    err = demoTransceiveBlocking( expTransacSelectApp, sizeof(expTransacSelectApp), &rxData, &rxLen, RFAL_FWT_NONE );
+
+    if( (err == ERR_NONE) && (*rxLen > 2) && rxData[*rxLen-2] == 0x90 && rxData[*rxLen-1] == 0x00)
+    {
+       //memcpy(select_resp,rxData,*rxLen-2);
+
+        return 0;
+    }
+    else
+    {
+         LOG_INF("select fail\n");
+        return -1;
+    }
+}
+void uaap_expedited_standard_transaction( void )
+{
+ int  err;
+    if(0 != make_select_cmd())
+    {
+        return;
+    }
+    if(0 != Make_AUTH0_cmd())
+    {
+        return;
+    }
+   
+    Make_AUTH1_cmd();
+    Make_control_flow_cmd();
+    
+
+}
\ No newline at end of file
-- 
2.33.0.windows.2

