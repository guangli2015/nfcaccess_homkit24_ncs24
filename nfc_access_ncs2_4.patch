From 1b24a286f9c2175b7ee68cbf00f21100e6c5e2ab Mon Sep 17 00:00:00 2001
From: andrew li <andrew.li@nordicsemi.no>
Date: Fri, 15 Dec 2023 16:13:05 +0800
Subject: [PATCH] homekey release 12/15

---
 CMakeLists.txt                                |    7 +-
 adk/PAL/nRF52/HAPPlatformNfcAccess.c          |   34 +-
 .../nrf52840dk_nrf52840.overlay               |   34 +
 samples/lock/CMakeLists.txt                   |    2 +
 samples/lock/prj.conf                         |   25 +-
 samples/lock/prj_debug.conf                   |   32 +-
 samples/lock/src/app.c                        |   10 +
 samples/lock/src/tag_reader.c                 |   95 +
 samples/lock/src/uaap_cmds.c                  | 1690 +++++++++++++++++
 9 files changed, 1921 insertions(+), 8 deletions(-)
 create mode 100644 samples/lock/src/tag_reader.c
 create mode 100644 samples/lock/src/uaap_cmds.c

diff --git a/CMakeLists.txt b/CMakeLists.txt
index c9b129e..345f5bd 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -82,6 +82,10 @@ if(CONFIG_HOMEKIT)
     target_compile_definitions(homekit_interface INTERFACE
       HAVE_NFC=1
       HAP_FEATURE_NFC=1
+      HAVE_NFC_ACCESS=1
+      HAP_FEATURE_NFC_ACCESS=1
+      HAVE_KEY_EXPORT=1
+      HAP_FEATURE_KEY_EXPORT=1
     )
   else()
     target_compile_definitions(homekit_interface INTERFACE
@@ -256,7 +260,7 @@ endif()
   FILE(GLOB app_generic_input adk/Applications/Common/Platform/AppUserInputGeneric.c)
   FILE(GLOB app_db adk/Applications/Common/DB/*.c)
   FILE(GLOB app_helper adk/Applications/Common/Helper/*.c)
-
+  FILE(GLOB adk_pal_nfc_access adk/PAL/nRF52/HAPPlatformNfcAccess.c)
   list(FILTER app_helper EXCLUDE REGEX .*/adk/Applications/Common/Helper/StandardInputHandler.c)
 
   
@@ -273,6 +277,7 @@ endif()
     ${app_generic_input}
     ${app_db}
     ${app_helper}
+    ${adk_pal_nfc_access}
   )
   
   zephyr_library_include_directories(${ZEPHYR_BASE}/subsys/bluetooth/host)
diff --git a/adk/PAL/nRF52/HAPPlatformNfcAccess.c b/adk/PAL/nRF52/HAPPlatformNfcAccess.c
index e4a8d27..079fcde 100644
--- a/adk/PAL/nRF52/HAPPlatformNfcAccess.c
+++ b/adk/PAL/nRF52/HAPPlatformNfcAccess.c
@@ -50,9 +50,22 @@
 #include "HAPCharacteristicTypes.h"
 #include "HAPCrypto.h"
 #include "HAPPlatform.h"
-
+#include <zephyr/logging/log.h>
+LOG_MODULE_DECLARE(st25r3916);//add by andrew
 #if HAP_FEATURE_ENABLED(HAP_FEATURE_NFC_ACCESS)
-
+//add by andrew
+#define PRINT_HEX(p_label, p_text, len)\
+	({\
+		LOG_INF("---- %s (len: %u): ----", p_label, len);\
+		LOG_HEXDUMP_INF(p_text, len, "Content:");\
+		LOG_INF("---- %s end  ----", p_label);\
+	})
+// add by andrew
+extern uint8_t reader_SK[NFC_ACCESS_READER_KEY_BYTES];
+extern uint8_t reader_group_id[NFC_ACCESS_KEY_IDENTIFIER_BYTES];
+extern uint8_t issuekey_identifier[8];
+extern bool device_credential_key_added;
+extern void writeToFlash(void *data , size_t len);
 /**
  * The salt value used with a key value to create a hash for the Identifier field
  */
@@ -831,7 +844,9 @@ HAPError HAPPlatformNfcAccessIssuerKeyAdd(
     HAPRawBufferCopyBytes(entry->identifier, identifier, NFC_ACCESS_KEY_IDENTIFIER_BYTES);
 
     // VENDOR-TODO: Add issuer key to the reader
-
+     PRINT_HEX("issuekey",issuerKey->key,  issuerKey->keyNumBytes);
+     PRINT_HEX("Identifier",  identifier, NFC_ACCESS_KEY_IDENTIFIER_BYTES);
+     HAPRawBufferCopyBytes(issuekey_identifier, identifier, NFC_ACCESS_KEY_IDENTIFIER_BYTES);
     nfcAccessIssuerKeyList.numEntries++;
 
     HAPError err = HAPPlatformKeyValueStoreSet(
@@ -1110,7 +1125,9 @@ HAPError HAPPlatformNfcAccessDeviceCredentialKeyAdd(
 
     // VENDOR-TODO: Either add device credential key to the reader or update the entry with a new key if the LRU is
     // evicted
-
+    device_credential_key_added=true;
+    PRINT_HEX("deviceCredentialKey",deviceCredentialKey->key,  deviceCredentialKey->keyNumBytes);
+     PRINT_HEX("issuerKeyIdentifier",  deviceCredentialKey->issuerKeyIdentifier, NFC_ACCESS_KEY_IDENTIFIER_BYTES);
     IncrementDeviceCredentialKeyNumEntries(deviceCredentialKey->state);
 
     if (nfcAccessDeviceCredentialKeyList.counter == 0) {
@@ -1289,6 +1306,15 @@ HAPError HAPPlatformNfcAccessReaderKeyAdd(
     }
 
     // VENDOR-TODO: Add reader key to the reader
+    // add by andrew
+    uint8_t temp[40];
+    
+     PRINT_HEX("reader_SKlan",readerKey->key,  readerKey->keyNumBytes);
+     PRINT_HEX("reader_group_id", identifier, NFC_ACCESS_KEY_IDENTIFIER_BYTES);
+     
+     HAPRawBufferCopyBytes(temp, identifier, NFC_ACCESS_KEY_IDENTIFIER_BYTES);
+     HAPRawBufferCopyBytes(temp+NFC_ACCESS_KEY_IDENTIFIER_BYTES, readerKey->key, readerKey->keyNumBytes);
+     writeToFlash(temp, 40);
 
     *statusCode = NFC_ACCESS_STATUS_CODE_SUCCESS;
     return kHAPError_None;
diff --git a/samples/common/configuration/nrf52840dk_nrf52840/nrf52840dk_nrf52840.overlay b/samples/common/configuration/nrf52840dk_nrf52840/nrf52840dk_nrf52840.overlay
index 0357cfa..994ba2f 100644
--- a/samples/common/configuration/nrf52840dk_nrf52840/nrf52840dk_nrf52840.overlay
+++ b/samples/common/configuration/nrf52840dk_nrf52840/nrf52840dk_nrf52840.overlay
@@ -11,6 +11,22 @@
 &pwm0 {
 	status = "disabled";
 };
+&spi0 {
+	compatible = "nordic,nrf-spi";
+	status = "okay";
+	cs-gpios = <&gpio1 12 GPIO_ACTIVE_LOW>;
+
+	pinctrl-0 = <&spi0_default_alt>;
+	pinctrl-1 = <&spi0_sleep_alt>;
+	pinctrl-names = "default", "sleep";
+	st25r3911b@0 {
+		compatible = "st,st25r3911b";
+		reg = <0>;
+		spi-max-frequency = <4000000>;
+		irq-gpios = <&gpio0 3 GPIO_ACTIVE_HIGH>;
+		led-nfca-gpios = <&gpio0 29 GPIO_ACTIVE_HIGH>;
+	};
+};
 &spi1 {
 	status = "disabled";
 };
@@ -20,3 +36,21 @@
 &usbd {
 	status = "disabled";
 };
+&pinctrl {
+	spi0_default_alt: spi0_default_alt {
+		group1 {
+			psels = <NRF_PSEL(SPIM_SCK, 1, 15)>,
+				<NRF_PSEL(SPIM_MOSI, 1, 13)>,
+				<NRF_PSEL(SPIM_MISO, 1, 14)>;
+		};
+	};
+
+	spi0_sleep_alt: spi0_sleep_alt {
+		group1 {
+			psels = <NRF_PSEL(SPIM_SCK, 1, 15)>,
+				<NRF_PSEL(SPIM_MOSI, 1, 13)>,
+				<NRF_PSEL(SPIM_MISO, 1, 14)>;
+			low-power-enable;
+		};
+	};
+};
diff --git a/samples/lock/CMakeLists.txt b/samples/lock/CMakeLists.txt
index cdcd7a4..6fd1bd4 100644
--- a/samples/lock/CMakeLists.txt
+++ b/samples/lock/CMakeLists.txt
@@ -45,6 +45,8 @@ find_package(Zephyr HINTS $ENV{ZEPHYR_BASE})
 project(homekit_lock)
 
 target_sources(app PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/src/app.c)
+target_sources(app PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/src/tag_reader.c)
+target_sources(app PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/src/uaap_cmds.c)
 target_sources(app PRIVATE ${COMMON_ROOT}/src/main.c)
 target_sources(app PRIVATE ${COMMON_ROOT}/src/hap.c)
 
diff --git a/samples/lock/prj.conf b/samples/lock/prj.conf
index 684d8b9..0604428 100644
--- a/samples/lock/prj.conf
+++ b/samples/lock/prj.conf
@@ -43,8 +43,9 @@ CONFIG_MCUBOOT_IMAGE_VERSION="1.0.0+0"
 CONFIG_BOOTLOADER_MCUBOOT=y
 
 # Miscellaneous
+CONFIG_MAIN_STACK_SIZE=8192
 CONFIG_MPU_STACK_GUARD=y
-CONFIG_HEAP_MEM_POOL_SIZE=1024
+CONFIG_HEAP_MEM_POOL_SIZE=8192
 CONFIG_ASSERT=n
 CONFIG_DK_LIBRARY=y
 CONFIG_REBOOT=y
@@ -62,3 +63,25 @@ CONFIG_UART_CONSOLE=n
 
 # Stacks
 CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE=4492
+
+
+CONFIG_SPI=y
+
+CONFIG_ST25R3916_LIB=y
+CONFIG_POLL=y
+
+
+
+#CONFIG_ST25R3916_LIB_LOG_LEVEL_INF=y
+#CONFIG_LOG_DEFAULT_LEVEL=4
+
+# Enable nordic security backend and PSA APIs
+CONFIG_NRF_SECURITY=y
+CONFIG_MBEDTLS_PSA_CRYPTO_C=y
+
+CONFIG_MBEDTLS_ENABLE_HEAP=y
+CONFIG_MBEDTLS_HEAP_SIZE=8192
+# The Zephyr CMSIS emulation assumes that ticks are ms, currently
+CONFIG_SYS_CLOCK_TICKS_PER_SEC=1000
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_FLASH=y
\ No newline at end of file
diff --git a/samples/lock/prj_debug.conf b/samples/lock/prj_debug.conf
index 6994fc7..d8f4534 100644
--- a/samples/lock/prj_debug.conf
+++ b/samples/lock/prj_debug.conf
@@ -43,15 +43,19 @@ CONFIG_MCUBOOT_IMAGE_VERSION="1.0.0+0"
 CONFIG_BOOTLOADER_MCUBOOT=y
 
 # Miscellaneous
+CONFIG_MAIN_STACK_SIZE=8192
 CONFIG_MPU_STACK_GUARD=y
-CONFIG_HEAP_MEM_POOL_SIZE=1024
+CONFIG_HEAP_MEM_POOL_SIZE=8192
 CONFIG_ASSERT=n
 CONFIG_DK_LIBRARY=y
 CONFIG_REBOOT=y
 CONFIG_BOOT_BANNER=y
 
 # HomeKit Protocol
-CONFIG_HAP_LOG_LEVEL_DEBUG=y
+#CONFIG_HAP_LOG_LEVEL_DEBUG=y
+CONFIG_HAP_LOG_LEVEL_NONE=y
+#CONFIG_HAP_LOG_LEVEL_INFO=y
+#CONFIG_HAP_LOG_LEVEL_ERROR=y
 CONFIG_HAP_ASSERTS=y
 CONFIG_HAP_PRECONDITIONS=y
 CONFIG_HAP_LOG_MESSAGE_MAX_BYTES=512
@@ -84,3 +88,27 @@ CONFIG_RESET_ON_FATAL_ERROR=n
 
 # Stacks
 CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE=4492
+
+CONFIG_SPI=y
+
+CONFIG_ST25R3916_LIB=y
+CONFIG_POLL=y
+
+
+
+#CONFIG_ST25R3916_LIB_LOG_LEVEL_INF=y
+#CONFIG_LOG_DEFAULT_LEVEL=4
+
+# Enable nordic security backend and PSA APIs
+CONFIG_NRF_SECURITY=y
+CONFIG_MBEDTLS_PSA_CRYPTO_C=y
+
+CONFIG_MBEDTLS_ENABLE_HEAP=y
+CONFIG_MBEDTLS_HEAP_SIZE=8192
+
+# The Zephyr CMSIS emulation assumes that ticks are ms, currently
+CONFIG_SYS_CLOCK_TICKS_PER_SEC=1000
+
+
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_FLASH=y
\ No newline at end of file
diff --git a/samples/lock/src/app.c b/samples/lock/src/app.c
index fbcee27..a10deec 100644
--- a/samples/lock/src/app.c
+++ b/samples/lock/src/app.c
@@ -965,6 +965,16 @@ HAPError HandleLockMechanismLockTargetStateWrite(
     return kHAPError_None;
 }
 
+void LockStateChangebyNfc()
+{
+      uint8_t value;
+       value=1-accessoryConfiguration.state.currentState;
+       if (value) {
+        SetLockTargetState(kHAPCharacteristicValue_LockTargetState_Secured);
+    } else {
+        SetLockTargetState(kHAPCharacteristicValue_LockTargetState_Unsecured);
+    }
+}
 /**
  * Handle read request to the 'Battery Level' characteristic of the Battery service.
  */
diff --git a/samples/lock/src/tag_reader.c b/samples/lock/src/tag_reader.c
new file mode 100644
index 0000000..8bf54f0
--- /dev/null
+++ b/samples/lock/src/tag_reader.c
@@ -0,0 +1,95 @@
+/* main.c - Application main entry point */
+
+/*
+ * Copyright (c) 2019 Nordic Semiconductor ASA
+ *
+ * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
+ */
+
+#include <zephyr/types.h>
+#include <stddef.h>
+#include <stdbool.h>
+#include <string.h>
+#include <zephyr/kernel.h>
+#include <zephyr/sys/printk.h>
+//#include <st25r3911b_nfca.h>
+#include <nfc/ndef/msg_parser.h>
+#include <nfc/ndef/le_oob_rec_parser.h>
+#include <nfc/t2t/parser.h>
+#include <nfc/t4t/ndef_file.h>
+#include <nfc/t4t/isodep.h>
+#include <nfc/t4t/hl_procedure.h>
+#include <nfc/ndef/ch_rec_parser.h>
+#include <zephyr/sys/byteorder.h>
+#include <st25r3916_nfca.h>
+
+#include "st25r3916_irq.h"
+#include "rfal_nfc.h"
+#include "demo.h"
+
+#define MY_STACK_SIZE 1024
+#define MY_PRIORITY -2
+static K_SEM_DEFINE(irq_sem, 0, 1);
+//static K_SEM_DEFINE(rfal_sem, 0, 1);
+int is=0;
+extern bool device_credential_key_added;
+extern void flash_setup();
+
+void my_entry_point(int unused1, int unused2, int unused3)
+{
+	int err;
+	while(1){
+		err = k_sem_take(&irq_sem, K_FOREVER);
+		if (err) {
+			return;
+		}
+                
+		st25r3916Isr();
+               // k_sem_give(&rfal_sem);
+                //printk("&");
+
+	}
+
+}
+
+K_THREAD_STACK_DEFINE(my_stack_area, MY_STACK_SIZE);
+
+ //K_SEM_DEFINE(debug_sem, 0, 1);
+
+void tag_reader(int unused1, int unused2, int unused3)
+{
+	int err;
+    printk("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
+	device_credential_key_added=false;
+#if 1
+	st25r3916InitInterrupts(&irq_sem);
+	struct k_thread my_thread_data;
+	
+	k_tid_t my_tid = k_thread_create(&my_thread_data, my_stack_area,
+									 K_THREAD_STACK_SIZEOF(my_stack_area),
+									 my_entry_point,
+									 NULL, NULL, NULL,
+									 MY_PRIORITY, 0, K_NO_WAIT);
+
+	err = st25r3916_nfca_init();
+	if (err) {
+		return err;
+	}
+    
+	flash_setup();
+	
+#if 1
+if(demoIni())
+{
+        printk("init ok\n");
+         while(1)
+        {
+                demoCycle();
+
+                k_sleep(K_MSEC(30));
+        }
+}
+#endif
+#endif
+}
+K_THREAD_DEFINE(tag, 8192, tag_reader, NULL, NULL, NULL, K_LOWEST_APPLICATION_THREAD_PRIO , 0, 0);
diff --git a/samples/lock/src/uaap_cmds.c b/samples/lock/src/uaap_cmds.c
new file mode 100644
index 0000000..84e4344
--- /dev/null
+++ b/samples/lock/src/uaap_cmds.c
@@ -0,0 +1,1690 @@
+/******************************************************************************
+  * @attention
+  *
+  * COPYRIGHT 2019 STMicroelectronics, all rights reserved
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied,
+  * AND SPECIFICALLY DISCLAIMING THE IMPLIED WARRANTIES OF MERCHANTABILITY,
+  * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  *
+******************************************************************************/
+
+
+/*! \file
+ *
+ *  \author 
+ *
+ *  \brief Demo application
+ *
+ *  This demo shows how to poll for several types of NFC cards/devices and how 
+ *  to exchange data with these devices, using the RFAL library.
+ *
+ *  This demo does not fully implement the activities according to the standards,
+ *  it performs the required to communicate with a card/device and retrieve 
+ *  its UID. Also blocking methods are used for data exchange which may lead to
+ *  long periods of blocking CPU/MCU.
+ *  For standard compliant example please refer to the Examples provided
+ *  with the RFAL library.
+ * 
+ */
+ 
+/*
+ ******************************************************************************
+ * INCLUDES
+ ******************************************************************************
+ */
+#include <stdio.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <stdarg.h>
+#include <zephyr/kernel.h>
+#include <stdbool.h>
+#include <assert.h>
+#include <zephyr/sys/util.h>
+#include <zephyr/sys/byteorder.h>
+#include <string.h>
+#include <zephyr/logging/log.h>
+#include "demo.h"
+#include "utils.h"
+#include "rfal_nfc.h"
+#include "logger.h"
+#include <psa/crypto.h>
+#include <psa/crypto_extra.h>
+#include "HAP+API.h"
+#include "HAP.h"
+
+#include "AccessoryInformationServiceDB.h"
+#include "App.h"
+#include "AppBase.h"
+#define SPI_FLASH_TEST_REGION_OFFSET 0xff000
+
+#define SPI_FLASH_SECTOR_SIZE        4096
+LOG_MODULE_DECLARE(st25r3916);
+
+#define platformLog LOG_INF
+/*
+******************************************************************************
+* GLOBAL DEFINES
+******************************************************************************
+*/
+
+
+
+/*
+ ******************************************************************************
+ * GLOBAL MACROS
+ ******************************************************************************
+ */
+#define UAAP_DEBUG
+#ifdef UAAP_DEBUG
+#define PRINT_HEX(p_label, p_text, len)\
+	({\
+		LOG_INF("---- %s (len: %u): ----", p_label, len);\
+		LOG_HEXDUMP_INF(p_text, len, "Content:");\
+		LOG_INF("---- %s end  ----", p_label);\
+	})
+#else
+#define PRINT_HEX(p_label, p_text, len)
+#endif
+/*
+ ******************************************************************************
+ * LOCAL VARIABLES
+ ******************************************************************************
+ */                                 
+/* VASUP-A Command: TCI must be set according to data received via MFi Program  */
+static uint8_t demoEcpVasup[] = { 0x6A,    /* VASUP-A Command             */
+                                  0x02,    /* Byte1  - Format: 2.0        */
+                                  0xCB,    /* Byte2  - Terminal Info      */
+                                  0x02,    /* Byte3  - Terminal Type      */
+                                  0x04,    /* Byte4  - Terminal Subtype   */
+                                  0x02,    /* Byte5  - TCI 1              */
+                                  0x11,    /* Byte6  - TCI 2              */
+                                  0x00,    /* Byte7  - TCI 3              */
+                                  0xb0,0x2a,0x52,0x74,0xec,0x02,0x13,0x4d,  /* Reader Identifier */
+};
+static uint8_t expTransacSelectApp[] = { 0x00, 0xA4, 0x04, 0x00, 0x0c, 0xA0, 0x00, 0x00, 0x08, 0x58, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00};
+
+
+static uint8_t reader_group_head[]={0x4d,0x10};
+
+uint8_t reader_group_id[8]={0};
+static uint8_t reader_group_sub_id[8];
+
+static uint8_t transaction_id_head[]={0x4c,0x10};
+static uint8_t transaction_id[16];
+static uint8_t auth1_usage[]={0x93,0x04,0x41,0x5d,0x95,0x69};
+
+static uint8_t reader_ePK[65];
+static uint8_t endp_ePK[65];
+static uint8_t m_signature[64];
+static uint8_t m_hash[32];
+static uint8_t datafield[110];//plain text for sign auth1
+static psa_key_handle_t keypair_handle;
+static psa_key_handle_t auth1_keypair_handle;
+static psa_key_handle_t ecdh_keypair_handle;
+static psa_key_handle_t hkdf_in_keypair_handle;
+static psa_key_handle_t hkdf_out_keypair_handle;
+static psa_key_handle_t aes_keypair_handle;
+static psa_key_handle_t endp_pub_key_handle;
+static psa_key_handle_t cmac_key_handle;
+
+static psa_key_handle_t hkdf_in_handle_stepup;
+static psa_key_handle_t hkdf_out_handle_stepup;
+static psa_key_handle_t aesgcm_key_handle;
+static psa_key_handle_t aesgcm_key_handle_device;
+static psa_key_handle_t hkdf_in_handle_fast;
+static psa_key_handle_t hkdf_out_handle_fast;
+static psa_key_handle_t get_reader_pubkey_handle;
+uint8_t reader_SK[32]={0};
+static uint8_t reader_PK[65];
+static uint8_t reader_eSK[32]={0};
+
+static uint8_t endp_pub_key[65];
+static uint8_t hkdf_output_key48[48];
+static uint8_t s_secret[32]={0};
+
+
+static int import_ecdsa_prv_key(void);
+static int create_ecdh_keypair(psa_key_handle_t *key_handle);
+static int calculate_ecdh_secret(psa_key_handle_t *key_handle,
+			  uint8_t *pub_key,
+			  size_t pub_key_len,
+			  uint8_t *secret,
+			  size_t secret_len);
+static int import_hkdf_input_key(uint8_t *kdh);
+static int derive_hkdf(size_t out_key_size,uint8_t * m_ainfo , size_t info_len);
+static int aes_import_key(uint8_t * kenc);
+static int decrypt_cbc_aes(uint8_t * m_encrypted_text,size_t en_size,uint8_t *m_decrypted_text ,size_t de_size,uint8_t * m_iv);
+static int import_ecdsa_pub_key(void);
+static int verify_endp_message(uint8_t *endp_sig,size_t sig_size);
+static int encrypt_cbc_aes(uint8_t * m_encrypted_text,size_t en_size,uint8_t *m_plain_text ,size_t pl_size,uint8_t * m_iv);
+
+uint8_t issuekey_identifier[8];
+bool device_credential_key_added=false;
+static uint8_t device_credential_key[64];
+static uint8_t kPersistent[32];
+//static bool auth1_have_done=false;
+static bool reader_group_sub_id_gen=false;
+static	bool crypotogram_matched=false;
+extern void read_from_flash(uint8_t *tmp, size_t size);
+
+static int crypto_finish(void)
+{
+	psa_status_t status;
+
+	/* Destroy the key handle */
+	status = psa_destroy_key(keypair_handle);
+
+
+	status = psa_destroy_key(auth1_keypair_handle);
+
+
+    status = psa_destroy_key(ecdh_keypair_handle);
+
+
+    status = psa_destroy_key(hkdf_in_keypair_handle);
+
+
+    status = psa_destroy_key(hkdf_out_keypair_handle);
+
+
+    status = psa_destroy_key(aes_keypair_handle);
+
+
+     status = psa_destroy_key(endp_pub_key_handle);
+
+
+	status = psa_destroy_key(cmac_key_handle);
+
+
+	status = psa_destroy_key(hkdf_in_handle_stepup);
+
+
+	status = psa_destroy_key(hkdf_out_handle_stepup);
+	
+	status = psa_destroy_key(aesgcm_key_handle);
+
+	status = psa_destroy_key(aesgcm_key_handle_device);
+
+
+	status = psa_destroy_key(hkdf_in_handle_fast);
+
+
+	status = psa_destroy_key(hkdf_out_handle_fast);
+
+	status = psa_destroy_key(get_reader_pubkey_handle);
+
+	
+	return 0;
+}
+static int generate_ephem_keypair(void)
+{
+	psa_status_t status;
+	size_t olen;
+
+	LOG_INF("Generating random ECDSA keypair...");
+
+	/* Configure the key attributes */
+	psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
+
+	/* Configure the key attributes */
+	psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_SIGN_HASH | PSA_KEY_USAGE_EXPORT);
+	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
+	psa_set_key_algorithm(&key_attributes, PSA_ALG_ECDSA(PSA_ALG_SHA_256));
+	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_FAMILY_SECP_R1));
+	psa_set_key_bits(&key_attributes, 256);
+
+	/* Generate a random keypair. The keypair is not exposed to the application,
+	 * we can use it to signing/verification the key handle.
+	 */
+	status = psa_generate_key(&key_attributes, &keypair_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_generate_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Export the public key */
+	status = psa_export_public_key(keypair_handle, reader_ePK, sizeof(reader_ePK), &olen);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_export_public_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+    //PRINT_HEX("reader_ePK", reader_ePK, 65);
+    status = psa_export_key(keypair_handle, reader_eSK, sizeof(reader_eSK), &olen);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_export_prv_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+    //PRINT_HEX("reader_eSK", reader_eSK, 32);
+	/* After the key handle is acquired the attributes are not needed */
+	psa_reset_key_attributes(&key_attributes);
+
+
+	return 0;
+}
+
+
+int sign_message(void)
+{
+	uint32_t output_len;
+	psa_status_t status;
+
+	LOG_INF("Signing a message using ECDSA...");
+
+	/* Compute the SHA256 hash*/
+	status = psa_hash_compute(PSA_ALG_SHA_256,
+				  datafield,
+				  sizeof(datafield),
+				  m_hash,
+				  sizeof(m_hash),
+				  &output_len);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_hash_compute failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Sign the hash */
+	status = psa_sign_hash(auth1_keypair_handle,
+			       PSA_ALG_ECDSA(PSA_ALG_SHA_256),
+			       m_hash,
+			       sizeof(m_hash),
+			       m_signature,
+			       sizeof(m_signature),
+			       &output_len);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_sign_hash failed! (Error: %d)", status);
+		return -1;
+	}
+
+	LOG_INF("Signing the message successful!");
+    
+	return 0;
+}
+
+//static uint8_t m_pub_key[65];//for test
+static int import_ecdsa_prv_key(void)
+{
+	/* Configure the key attributes */
+	psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
+	psa_status_t status;
+	/* Configure the key attributes */
+	psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_SIGN_HASH | PSA_KEY_USAGE_VERIFY_HASH);
+	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
+	psa_set_key_algorithm(&key_attributes, PSA_ALG_ECDSA(PSA_ALG_SHA_256));
+	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_FAMILY_SECP_R1));
+	//psa_set_key_bits(&key_attributes, 256);
+   // PRINT_HEX("reader_SKecdsa", reader_SK, 32);
+	status = psa_import_key(&key_attributes, reader_SK, sizeof(reader_SK), &auth1_keypair_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_import_key failed! (Error: %d)", status);
+		return -1;
+	}
+    size_t olen;
+
+	/* After the key handle is acquired the attributes are not needed */
+	psa_reset_key_attributes(&key_attributes);
+
+	return 0;
+}
+
+static int create_ecdh_keypair(psa_key_handle_t *key_handle)
+{
+	psa_status_t status;
+	psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
+
+	/* Crypto settings for ECDH using the SHA256 hashing algorithm,
+	 * the secp256r1 curve
+	 */
+	psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_DERIVE);
+	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
+	psa_set_key_algorithm(&key_attributes, PSA_ALG_ECDH);
+	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_FAMILY_SECP_R1));
+	psa_set_key_bits(&key_attributes, 256);
+
+	status = psa_import_key(&key_attributes,reader_eSK,sizeof(reader_eSK), key_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_generate_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+	psa_reset_key_attributes(&key_attributes);
+
+	LOG_INF("ECDH keypair import successfully!");
+
+	return 0;
+}
+
+static int calculate_ecdh_secret(psa_key_handle_t *key_handle,
+			  uint8_t *pub_key,
+			  size_t pub_key_len,
+			  uint8_t *secret,
+			  size_t secret_len)
+{
+	uint32_t output_len;
+	psa_status_t status;
+
+	/* Perform the ECDH key exchange to calculate the secret */
+	status = psa_raw_key_agreement(
+		PSA_ALG_ECDH, *key_handle, pub_key, pub_key_len, secret, secret_len, &output_len);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_raw_key_agreement failed! (Error: %d)", status);
+		return -1;
+	}
+
+	LOG_INF("ECDH secret calculated successfully!");
+
+	return 0;
+}
+
+static int import_hkdf_input_key(uint8_t *kdh)
+{
+	psa_status_t status;
+	psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
+
+	/* Configure the input key attributes */
+	psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_DERIVE);
+	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
+	psa_set_key_algorithm(&key_attributes, PSA_ALG_HKDF(PSA_ALG_SHA_256));
+	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_DERIVE);
+	psa_set_key_bits(&key_attributes,
+			 32 * 8);
+    //PRINT_HEX("kdhhkdf", kdh, 32);
+	/* Import the master key into the keystore */
+	status = psa_import_key(&key_attributes,
+				kdh,
+				32,
+				&hkdf_in_keypair_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_import_key failed! (Error: %d)", status);
+		return -1;
+	}
+LOG_INF("import_hkdf_input_key successfully!");
+	return 0;
+}
+static int import_hkdf_input_key_fast(uint8_t *key)
+{
+	psa_status_t status;
+	psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
+
+	/* Configure the input key attributes */
+	psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_DERIVE);
+	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
+	psa_set_key_algorithm(&key_attributes, PSA_ALG_HKDF(PSA_ALG_SHA_256));
+	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_DERIVE);
+	psa_set_key_bits(&key_attributes,
+			 32 * 8);
+    //PRINT_HEX("kdhhkdf", kdh, 32);
+	/* Import the master key into the keystore */
+	status = psa_import_key(&key_attributes,
+				key,
+				32,
+				&hkdf_in_handle_fast);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_import_key failed! (Error: %d)", status);
+		return -1;
+	}
+LOG_INF("import_hkdf_input_key fast successfully!");
+	return 0;
+}
+static int derive_hkdf(size_t out_key_size,uint8_t * m_ainfo , size_t info_len)
+{
+	psa_status_t status;
+	psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
+	psa_key_derivation_operation_t operation =
+		PSA_KEY_DERIVATION_OPERATION_INIT;
+
+	LOG_INF("Deriving a key using HKDF and SHA256...");
+
+	/* Derived key settings
+	 * WARNING: This key usage makes the key exportable which is not safe and
+	 * is only done to demonstrate the validity of the results. Please do not use
+	 * this in production environments.
+	 */
+	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
+	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_RAW_DATA);
+	psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_EXPORT); /* DONT USE IN PRODUCTION */
+	psa_set_key_bits(&key_attributes, out_key_size * 8);
+
+	/* Set the derivation algorithm */
+	status = psa_key_derivation_setup(&operation,
+					  PSA_ALG_HKDF(PSA_ALG_SHA_256));
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_key_derivation_setup failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Set the master key for the operation */
+	status = psa_key_derivation_input_key(
+		&operation, PSA_KEY_DERIVATION_INPUT_SECRET, hkdf_in_keypair_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_key_derivation_input_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+    //PRINT_HEX("m_ainfo", m_ainfo, info_len);
+	/* Set the additional info for the operation */
+	status = psa_key_derivation_input_bytes(&operation,
+						PSA_KEY_DERIVATION_INPUT_INFO,
+						m_ainfo,
+						info_len);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_key_derivation_input_bytes failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Store the derived key in the keystore slot pointed by out_key_handle */
+	status = psa_key_derivation_output_key(&key_attributes, &operation, &hkdf_out_keypair_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_key_derivation_output_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Clean up the context */
+	status = psa_key_derivation_abort(&operation);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_key_derivation_abort failed! (Error: %d)", status);
+		return -1;
+	}
+
+	LOG_INF("Key derivation successful!");
+
+	return 0;
+}
+
+static int derive_hkdf_fast(size_t out_key_size,uint8_t * m_ainfo , size_t info_len)
+{
+	psa_status_t status;
+	psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
+	psa_key_derivation_operation_t operation =
+		PSA_KEY_DERIVATION_OPERATION_INIT;
+
+	LOG_INF("Deriving a key using HKDF and SHA256...");
+
+	/* Derived key settings
+	 * WARNING: This key usage makes the key exportable which is not safe and
+	 * is only done to demonstrate the validity of the results. Please do not use
+	 * this in production environments.
+	 */
+	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
+	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_RAW_DATA);
+	psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_EXPORT); /* DONT USE IN PRODUCTION */
+	psa_set_key_bits(&key_attributes, out_key_size * 8);
+
+	/* Set the derivation algorithm */
+	status = psa_key_derivation_setup(&operation,
+					  PSA_ALG_HKDF(PSA_ALG_SHA_256));
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_key_derivation_setup failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Set the master key for the operation */
+	status = psa_key_derivation_input_key(
+		&operation, PSA_KEY_DERIVATION_INPUT_SECRET, hkdf_in_handle_fast);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_key_derivation_input_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+    //PRINT_HEX("m_ainfo", m_ainfo, info_len);
+	/* Set the additional info for the operation */
+	status = psa_key_derivation_input_bytes(&operation,
+						PSA_KEY_DERIVATION_INPUT_INFO,
+						m_ainfo,
+						info_len);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_key_derivation_input_bytes failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Store the derived key in the keystore slot pointed by out_key_handle */
+	status = psa_key_derivation_output_key(&key_attributes, &operation, &hkdf_out_handle_fast);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_key_derivation_output_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Clean up the context */
+	status = psa_key_derivation_abort(&operation);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_key_derivation_abort failed! (Error: %d)", status);
+		return -1;
+	}
+
+	LOG_INF("Key derivation successful!");
+
+	return 0;
+}
+static int aes_import_key(uint8_t * kenc)
+{
+	psa_status_t status;
+
+	LOG_INF("Generating random AES key...");
+
+	/* Configure the key attributes */
+	psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
+
+	psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_ENCRYPT | PSA_KEY_USAGE_DECRYPT);
+	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
+	psa_set_key_algorithm(&key_attributes, PSA_ALG_CBC_NO_PADDING);
+	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_AES);
+	psa_set_key_bits(&key_attributes, 128);
+
+	/* Generate a random key. The key is not exposed to the application,
+	 * we can use it to encrypt/decrypt using the key handle
+	 */
+	//status = psa_generate_key(&key_attributes, &key_handle);
+	status = psa_import_key(&key_attributes, kenc, 16, &aes_keypair_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_generate_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* After the key handle is acquired the attributes are not needed */
+	psa_reset_key_attributes(&key_attributes);
+
+	LOG_INF("AES key generated successfully!");
+
+	return 0;
+}
+
+static int decrypt_cbc_aes(uint8_t * m_encrypted_text,size_t en_size,uint8_t *m_decrypted_text ,size_t de_size,uint8_t * m_iv)
+{
+	uint32_t olen;
+	psa_status_t status;
+	psa_cipher_operation_t operation = PSA_CIPHER_OPERATION_INIT;
+
+	LOG_INF("Decrypting using AES CBC MODE...");
+
+	/* Setup the decryption operation */
+	status = psa_cipher_decrypt_setup(&operation, aes_keypair_handle, PSA_ALG_CBC_NO_PADDING);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_cipher_decrypt_setup failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Set the IV generated in encryption */
+	status = psa_cipher_set_iv(&operation, m_iv, 16);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_cipher_set_iv failed! (Error: %d)", status);
+		return -1;
+	}
+//PRINT_HEX("Encrypted text", m_encrypted_text, en_size);
+	/* Perform the decryption */
+	status = psa_cipher_update(&operation, m_encrypted_text,
+				  en_size, m_decrypted_text,
+				   de_size, &olen);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_cipher_update failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Finalize the decryption */
+	status = psa_cipher_finish(&operation, m_decrypted_text + olen,
+				   de_size - olen,
+				   &olen);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_cipher_finish failed! (Error: %d)", status);
+		return -1;
+	}
+
+	PRINT_HEX("Decrypted text", m_decrypted_text, de_size);
+
+	LOG_INF("Decryption successful!");
+
+	/*  Clean up cipher operation context */
+	psa_cipher_abort(&operation);
+
+	return 0;
+}
+
+static int encrypt_cbc_aes(uint8_t * m_encrypted_text,size_t en_size,uint8_t *m_plain_text ,size_t pl_size,uint8_t * m_iv)
+{
+	uint32_t olen;
+	psa_status_t status;
+	psa_cipher_operation_t operation = PSA_CIPHER_OPERATION_INIT;
+
+	LOG_INF("Encrypting using AES CBC MODE...");
+
+	/* Setup the encryption operation */
+	status = psa_cipher_encrypt_setup(&operation, aes_keypair_handle, PSA_ALG_CBC_NO_PADDING);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_cipher_encrypt_setup failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Generate an IV */
+	//status = psa_cipher_generate_iv(&operation, m_iv, sizeof(m_iv), &olen);
+	status = psa_cipher_set_iv(&operation, m_iv, 16);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_cipher_generate_iv failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Perform the encryption */
+	status = psa_cipher_update(&operation, m_plain_text,
+				   pl_size, m_encrypted_text,
+				   en_size, &olen);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_cipher_update failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Finalize the encryption */
+	status = psa_cipher_finish(&operation, m_encrypted_text + olen,
+				   en_size - olen,
+				   &olen);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_cipher_finish failed! (Error: %d)", status);
+		return -1;
+	}
+
+	LOG_INF("Encryption successful!");
+	/*PRINT_HEX("IV", m_iv, sizeof(m_iv));
+	PRINT_HEX("Plaintext", m_plain_text, sizeof(m_plain_text));
+	PRINT_HEX("Encrypted text", m_encrypted_text, sizeof(m_encrypted_text));*/
+
+	/* Clean up cipher operation context */
+	psa_cipher_abort(&operation);
+
+	return 0;
+}
+
+static int import_ecdsa_pub_key(void)
+{
+	/* Configure the key attributes */
+	psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
+	psa_status_t status;
+	/* Configure the key attributes */
+	psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_VERIFY_HASH);
+	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
+	psa_set_key_algorithm(&key_attributes, PSA_ALG_ECDSA(PSA_ALG_SHA_256));
+	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_ECC_PUBLIC_KEY(PSA_ECC_FAMILY_SECP_R1));
+	//psa_set_key_bits(&key_attributes, 256);
+    PRINT_HEX("endp_pub_key", endp_pub_key, sizeof(endp_pub_key));
+	status = psa_import_key(&key_attributes, endp_pub_key, sizeof(endp_pub_key), &endp_pub_key_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_import_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* After the key handle is acquired the attributes are not needed */
+	psa_reset_key_attributes(&key_attributes);
+
+	return 0;
+}
+static int verify_endp_message(uint8_t *endp_sig,size_t sig_size)
+{
+	uint32_t output_len;
+	psa_status_t status;
+
+	LOG_INF("Verifying endp ECDSA signature...");
+
+	/* Compute the SHA256 hash*/
+	status = psa_hash_compute(PSA_ALG_SHA_256,
+				  datafield,
+				  sizeof(datafield),
+				  m_hash,
+				  sizeof(m_hash),
+				  &output_len);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_hash_compute failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Sign the hash */
+	status = psa_verify_hash(endp_pub_key_handle,
+			       PSA_ALG_ECDSA(PSA_ALG_SHA_256),
+			       m_hash,
+			       sizeof(m_hash),
+			       endp_sig,
+			       sig_size);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_sign_hash failed! (Error: %d)", status);
+		return -1;
+	}
+
+	LOG_INF("Verifying the message successful!");
+    
+	return 0;
+}
+
+static int import_cmac_key(uint8_t * key)
+{
+	/* Configure the key attributes */
+	psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
+	psa_status_t status;
+	/* Import a key */
+	psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_SIGN_MESSAGE | PSA_KEY_USAGE_VERIFY_MESSAGE);
+	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
+	psa_set_key_algorithm(&key_attributes, PSA_ALG_CMAC);
+	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_AES);
+	psa_set_key_bits(&key_attributes, 128);
+
+	status = psa_import_key(&key_attributes, key, 16, &cmac_key_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_import_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* After the key handle is acquired the attributes are not needed */
+	psa_reset_key_attributes(&key_attributes);
+
+	return 0;
+}
+
+static int cmac_sign(uint8_t *m_plain_text ,size_t pl_size,uint8_t *cmac ,size_t cmac_size)
+{
+	uint32_t olen;
+	psa_status_t status;
+	psa_mac_operation_t operation = PSA_MAC_OPERATION_INIT;
+
+	LOG_INF("Signing using CMAC ...");
+
+	status = psa_mac_sign_setup(&operation, cmac_key_handle, PSA_ALG_CMAC);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_mac_sign_setup failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Perform the HMAC signing */
+	status = psa_mac_update(&operation, m_plain_text, pl_size);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_mac_update failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Finalize the HMAC signing */
+	status = psa_mac_sign_finish(&operation, cmac, cmac_size, &olen);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_mac_sign_finish failed! (Error: %d)", status);
+		return -1;
+	}
+
+	LOG_INF("Signing CMAC successful!");
+	//PRINT_HEX("Plaintext", m_plain_text, sizeof(m_plain_text));
+	//PRINT_HEX("cMAC", cmac, sizeof(cmac));
+
+	return 0;
+}
+
+
+int get_reader_pub_key(void)
+{
+	psa_status_t status;
+	size_t olen;
+
+	
+
+	/* Configure the key attributes */
+	psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
+
+	/* Configure the key attributes */
+	psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_SIGN_HASH);
+	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
+	psa_set_key_algorithm(&key_attributes, PSA_ALG_ECDSA(PSA_ALG_SHA_256));
+	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_FAMILY_SECP_R1));
+	psa_set_key_bits(&key_attributes, 256);
+
+	status = psa_import_key(&key_attributes, reader_SK, sizeof(reader_SK), &get_reader_pubkey_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_import_key failed! (Error: %d)", status);
+		return -1;
+	}
+	/* Export the public key */
+	status = psa_export_public_key(get_reader_pubkey_handle, reader_PK, sizeof(reader_PK), &olen);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_export_public_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* After the key handle is acquired the attributes are not needed */
+	psa_reset_key_attributes(&key_attributes);
+
+	return 0;
+}
+int Make_AUTH0_cmd()
+{
+    psa_status_t status;
+    uint8_t auth0_head[]={0x80,0x80,0x01,0x01,0x6b,0x5c,0x02,0x02,0x00};
+    uint8_t reader_ePK_head[]={0x87,0x41};
+
+
+    uint8_t auth0_end[]={0x00};
+    uint8_t auth0_data[113]={0};
+
+    ReturnCode err;
+    uint16_t   *rxLen;
+    uint8_t    *rxData;
+    int rc;
+ //   uint8_t temp[40];
+    LOG_INF("AUTH0_make start...\n");
+ //   read_from_flash(temp,40);
+ //   memcpy(reader_group_id,temp,sizeof(reader_group_id));
+ //   memcpy(reader_SK,temp+sizeof(reader_group_id),sizeof(reader_SK));
+	PRINT_HEX("reader_SK",reader_SK, 32);
+    PRINT_HEX("r_g_id", reader_group_id, 8);
+   	/* Initialize PSA Crypto */
+	status = psa_crypto_init();
+	if (status != PSA_SUCCESS)
+		{
+            LOG_INF("psa_crypto_init failed!\n");
+            return -1;
+        }
+
+    status = generate_ephem_keypair();
+	if (status != 0) {
+		LOG_INF("generate_ecdsa_keypair fail");
+		return -1;
+	}
+    status = psa_generate_random(transaction_id, sizeof(transaction_id));
+		if (status != PSA_SUCCESS) {
+			LOG_INF("psa_generate_random failed! (Error: %d)", status);
+			return -1;
+		}
+	if(reader_group_sub_id_gen == false)
+	{
+    	status = psa_generate_random(reader_group_sub_id, sizeof(reader_group_sub_id));
+		if (status != PSA_SUCCESS) {
+			LOG_INF("psa_generate_random failed! (Error: %d)", status);
+			return -1;
+		}
+		reader_group_sub_id_gen=true;
+	}
+
+   // PRINT_HEX("transaction_id", transaction_id, 16);
+   // PRINT_HEX("reader_group_sub_id", reader_group_sub_id, 8);
+    memcpy(auth0_data,auth0_head,sizeof(auth0_head));
+    memcpy(auth0_data+sizeof(auth0_head),reader_ePK_head,sizeof(reader_ePK_head));
+    memcpy(auth0_data+sizeof(auth0_head)+sizeof(reader_ePK_head),reader_ePK,sizeof(reader_ePK));
+    memcpy(auth0_data+sizeof(auth0_head)+sizeof(reader_ePK_head)+sizeof(reader_ePK),transaction_id_head,sizeof(transaction_id_head));
+    memcpy(auth0_data+sizeof(auth0_head)+sizeof(reader_ePK_head)+sizeof(reader_ePK)+sizeof(transaction_id_head),transaction_id,sizeof(transaction_id));
+    memcpy(auth0_data+sizeof(auth0_head)+sizeof(reader_ePK_head)+sizeof(reader_ePK)+sizeof(transaction_id_head)+sizeof(transaction_id),reader_group_head,sizeof(reader_group_head));
+    memcpy(auth0_data+sizeof(auth0_head)+sizeof(reader_ePK_head)+sizeof(reader_ePK)+sizeof(transaction_id_head)+sizeof(transaction_id)+sizeof(reader_group_head),reader_group_id,sizeof(reader_group_id));
+    memcpy(auth0_data+sizeof(auth0_head)+sizeof(reader_ePK_head)+sizeof(reader_ePK)+sizeof(transaction_id_head)+sizeof(transaction_id)+sizeof(reader_group_head)+sizeof(reader_group_id),reader_group_sub_id,sizeof(reader_group_sub_id));
+    memcpy(auth0_data+sizeof(auth0_head)+sizeof(reader_ePK_head)+sizeof(reader_ePK)+sizeof(transaction_id_head)+sizeof(transaction_id)+sizeof(reader_group_head)+sizeof(reader_group_id)+sizeof(reader_group_sub_id),auth0_end,sizeof(auth0_end));
+
+    /* Exchange APDU: Unified Access APDUs */
+    err = demoTransceiveBlocking( auth0_data, sizeof(auth0_data), &rxData, &rxLen, RFAL_FWT_NONE );
+    if( (err == ERR_NONE) && (*rxLen > 2) && rxData[*rxLen-2] == 0x90 && rxData[*rxLen-1] == 0x00)
+    {
+        /* Here more APDUs to implement the protocol are required. */
+
+        if(*rxLen>67)
+        {
+            memcpy(endp_ePK,rxData+2,65);
+        }
+		 PRINT_HEX("au0Re", rxData, *rxLen);
+        //return 0;
+    }
+    else
+    {
+		//crypto_finish();
+        return -1;
+    }
+	import_hkdf_input_key_fast(kPersistent);
+	get_reader_pub_key();
+	PRINT_HEX("Reader_pub_key", reader_PK, 65);
+	uint8_t auth0_hkdf_info_64[185];
+	uint8_t info_str[]={0x56 ,0x6F ,0x6C ,0x61 ,0x74 ,0x69 ,0x6C ,0x65 ,0x46 ,0x61 ,0x73 ,0x74};
+	uint8_t interface_to_end_48[]={0x5E ,0x01 ,0x01 ,0x56 ,0x6F ,0x6C ,0x61 ,0x74 ,0x69 ,0x6C ,0x65 ,0x5C ,0x02 ,0x02 ,0x00 ,0x5C ,0x04 ,0x02 ,0x00 ,0x01 ,0x00 };
+    uint8_t interface_to_64[]={0x5E ,0x5C ,0x04 ,0x02 ,0x00 ,0x01 ,0x00 ,0x5C ,0x02 ,0x02 ,0x00 };
+	uint8_t flag[]={0x01,0x01};
+    memcpy(auth0_hkdf_info_64,reader_PK+1,32);
+	memcpy(auth0_hkdf_info_64+32,info_str,sizeof(info_str));
+    memcpy(auth0_hkdf_info_64+32+sizeof(info_str),reader_group_id,sizeof(reader_group_id));
+	memcpy(auth0_hkdf_info_64+32+sizeof(info_str)+sizeof(reader_group_id),reader_group_sub_id,sizeof(reader_group_sub_id));
+	memcpy(auth0_hkdf_info_64+32+sizeof(info_str)+sizeof(reader_group_id)+sizeof(reader_group_sub_id),endp_pub_key+1,32);
+	memcpy(auth0_hkdf_info_64+32+sizeof(info_str)+sizeof(reader_group_id)+sizeof(reader_group_sub_id)+32,interface_to_64,sizeof(interface_to_64));
+	memcpy(auth0_hkdf_info_64+32+sizeof(info_str)+sizeof(reader_group_id)+sizeof(reader_group_sub_id)+32+sizeof(interface_to_64),reader_ePK+1,32);
+	memcpy(auth0_hkdf_info_64+32+sizeof(info_str)+sizeof(reader_group_id)+sizeof(reader_group_sub_id)+32+sizeof(interface_to_64)+32,transaction_id,sizeof(transaction_id));
+	memcpy(auth0_hkdf_info_64+32+sizeof(info_str)+sizeof(reader_group_id)+sizeof(reader_group_sub_id)+32+sizeof(interface_to_64)+32+sizeof(transaction_id),flag,sizeof(flag));
+   	memcpy(auth0_hkdf_info_64+32+sizeof(info_str)+sizeof(reader_group_id)+sizeof(reader_group_sub_id)+32+sizeof(interface_to_64)+32+sizeof(transaction_id)+sizeof(flag),endp_ePK+1,32);
+	derive_hkdf_fast( 64,auth0_hkdf_info_64 , sizeof(auth0_hkdf_info_64));
+	uint8_t hkdf_output_64[64];
+	size_t olen;
+	status = psa_export_key(hkdf_out_handle_fast, hkdf_output_64, sizeof(hkdf_output_64), &olen);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_export_key failed! (Error: %d)", status);
+		
+	} 
+	PRINT_HEX("hkdf_64", hkdf_output_64,  sizeof(hkdf_output_64));
+     uint16_t i;
+	for(i=0;i<16;i++)
+	{
+		if(hkdf_output_64[i] == rxData[i+69])
+		{
+				crypotogram_matched=true;
+
+		}
+	}
+	if(crypotogram_matched==true)
+	{
+		LockStateChangebyNfc();
+	}
+    return 0;
+}
+
+
+int Make_AUTH1_cmd()
+{
+    uint8_t auth1_head[]={0x80,0x81,0x01,0x00,0x42};
+    uint8_t reader_sig_head[]={0x9e,0x40};
+    uint8_t auth1_end[]={0x00};
+    uint8_t   auth1_cmd[72];
+    uint8_t endp_ePKX_h[]={0x86,0x20};
+    uint8_t reader_ePKX_h[]={0x87,0x20};
+    uint8_t usage[]={0x93,0x04,0x41,0x5d,0x95,0x69};
+    ReturnCode err;
+    uint16_t   *rxLen;
+    uint8_t    *rxData;
+    memcpy(datafield,reader_group_head,sizeof(reader_group_head));
+    memcpy(datafield+sizeof(reader_group_head),reader_group_id,sizeof(reader_group_id));
+    memcpy(datafield+sizeof(reader_group_head)+sizeof(reader_group_id),reader_group_sub_id,sizeof(reader_group_sub_id));
+    memcpy(datafield+sizeof(reader_group_head)+sizeof(reader_group_id)+sizeof(reader_group_sub_id),endp_ePKX_h,sizeof(endp_ePKX_h));
+    memcpy(datafield+sizeof(reader_group_head)+sizeof(reader_group_id)+sizeof(reader_group_sub_id)+sizeof(endp_ePKX_h),endp_ePK+1,32);
+    memcpy(datafield+sizeof(reader_group_head)+sizeof(reader_group_id)+sizeof(reader_group_sub_id)+sizeof(endp_ePKX_h)+32,reader_ePKX_h,sizeof(reader_ePKX_h));
+    memcpy(datafield+sizeof(reader_group_head)+sizeof(reader_group_id)+sizeof(reader_group_sub_id)+sizeof(endp_ePKX_h)+32+sizeof(reader_ePKX_h),reader_ePK+1,32);
+    memcpy(datafield+sizeof(reader_group_head)+sizeof(reader_group_id)+sizeof(reader_group_sub_id)+sizeof(endp_ePKX_h)+32+sizeof(reader_ePKX_h)+32,transaction_id_head,sizeof(transaction_id_head));
+    memcpy(datafield+sizeof(reader_group_head)+sizeof(reader_group_id)+sizeof(reader_group_sub_id)+sizeof(endp_ePKX_h)+32+sizeof(reader_ePKX_h)+32+sizeof(transaction_id_head),transaction_id,sizeof(transaction_id));
+    memcpy(datafield+sizeof(reader_group_head)+sizeof(reader_group_id)+sizeof(reader_group_sub_id)+sizeof(endp_ePKX_h)+32+sizeof(reader_ePKX_h)+32+sizeof(transaction_id_head)+sizeof(transaction_id),usage,sizeof(usage));
+ 
+    import_ecdsa_prv_key();
+    sign_message();
+
+    memcpy(auth1_cmd,auth1_head,sizeof(auth1_head));
+    memcpy(auth1_cmd+sizeof(auth1_head),reader_sig_head,sizeof(reader_sig_head));
+    memcpy(auth1_cmd+sizeof(auth1_head)+sizeof(reader_sig_head),m_signature,sizeof(m_signature));
+    memcpy(auth1_cmd+sizeof(auth1_head)+sizeof(reader_sig_head)+sizeof(m_signature),auth1_end,sizeof(auth1_end));
+
+    err = demoTransceiveBlocking( auth1_cmd, sizeof(auth1_cmd), &rxData, &rxLen, RFAL_FWT_NONE );
+    if( (err == ERR_NONE) && (*rxLen > 2) && rxData[*rxLen-2] == 0x90 && rxData[*rxLen-1] == 0x00)
+    {
+        /* Here more APDUs to implement the protocol are required. */
+        //PRINT_HEX("au1Re", rxData, *rxLen);
+
+    }
+    else 
+    {   
+         //PRINT_HEX("au1ReE", rxData, *rxLen);
+		 //crypto_finish();
+		 return -1;
+    }
+
+   //  uint8_t s_secret[32]={0};
+    create_ecdh_keypair(&ecdh_keypair_handle);
+
+    calculate_ecdh_secret(&ecdh_keypair_handle,
+				       endp_ePK,
+				       sizeof(endp_ePK),
+				       s_secret,
+				       sizeof(s_secret));
+
+    uint8_t kdh_input[32+4+16];
+    uint8_t tmp[4]={0x00,0x00,0x00,0x01};
+    memcpy(kdh_input,s_secret,sizeof(s_secret));
+    memcpy(kdh_input+sizeof(s_secret),tmp,sizeof(tmp));
+    memcpy(kdh_input+sizeof(s_secret)+sizeof(tmp),transaction_id,sizeof(transaction_id));
+
+    uint32_t output_len;
+	psa_status_t status;
+    uint8_t d_kdh[32];
+	/* Compute the SHA256 hash*/
+	status = psa_hash_compute(PSA_ALG_SHA_256,
+				  kdh_input,
+				  sizeof(kdh_input),
+				  d_kdh,
+				  sizeof(d_kdh),
+				  &output_len);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_hash_compute failed! (Error: %d)", status);
+	}
+
+    //uint8_t hkdf_output_key48[48];
+    uint8_t auth1_hkdf_info_48[101];
+    uint8_t interface_to_end_48[]={0x5E ,0x01 ,0x01 ,0x56 ,0x6F ,0x6C ,0x61 ,0x74 ,0x69 ,0x6C ,0x65 ,0x5C ,0x02 ,0x02 ,0x00 ,0x5C ,0x04 ,0x02 ,0x00 ,0x01 ,0x00 };
+    memcpy(auth1_hkdf_info_48,reader_ePK+1,32);
+    memcpy(auth1_hkdf_info_48+32,endp_ePK+1,32);
+    memcpy(auth1_hkdf_info_48+32+32,transaction_id,sizeof(transaction_id));
+    memcpy(auth1_hkdf_info_48+32+32+sizeof(transaction_id),interface_to_end_48,sizeof(interface_to_end_48));
+
+    import_hkdf_input_key(d_kdh);
+    //PRINT_HEX("auth1_hkdf_info_48", auth1_hkdf_info_48, sizeof(auth1_hkdf_info_48));
+    derive_hkdf(48,auth1_hkdf_info_48,sizeof(auth1_hkdf_info_48));
+
+    size_t olen;
+    /* Export the generated key content to verify it's value */
+	status = psa_export_key(hkdf_out_keypair_handle, hkdf_output_key48, sizeof(hkdf_output_key48), &olen);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_export_key failed! (Error: %d)", status);
+		
+	}
+    //PRINT_HEX("key48", hkdf_output_key48, sizeof(hkdf_output_key48));
+    //uint8_t kPersistent[32];
+    uint8_t auth1_hkdf_info_32[103];
+    uint8_t interface_to_end_32[]={0x5E ,0x01 ,0x01 ,0x50 ,0x65 ,0x72 ,0x73 ,0x69 ,0x73 ,0x74 ,0x65 , 0x6e ,0x74 ,0x5C ,0x02 ,0x02 ,0x00 ,0x5C ,0x04 ,0x02 ,0x00 ,0x01 ,0x00 };
+    memcpy(auth1_hkdf_info_32,reader_ePK+1,32);
+    memcpy(auth1_hkdf_info_32+32,endp_ePK+1,32);
+    memcpy(auth1_hkdf_info_32+32+32,transaction_id,sizeof(transaction_id));
+    memcpy(auth1_hkdf_info_32+32+32+sizeof(transaction_id),interface_to_end_32,sizeof(interface_to_end_32));
+    derive_hkdf(32,auth1_hkdf_info_32,sizeof(auth1_hkdf_info_32));
+     /* Export the generated key content to verify it's value*/
+	status = psa_export_key(hkdf_out_keypair_handle, kPersistent, sizeof(kPersistent), &olen);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_export_key failed! (Error: %d)", status);
+		
+	} 
+    uint8_t iv_for_miv[16]={0};
+    uint8_t append_text[]={0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
+    uint8_t m_iv[16];
+    uint8_t m_decrypted_text[144]={0};
+    aes_import_key(hkdf_output_key48);
+    encrypt_cbc_aes(m_iv,sizeof(m_iv),append_text,sizeof(append_text),iv_for_miv);
+    decrypt_cbc_aes(rxData,(*rxLen)-10,m_decrypted_text ,(*rxLen)-10,m_iv);
+    memcpy(endp_pub_key,m_decrypted_text+2,65);
+ 
+    uint8_t endp_usage[]={0x93,0x04,0x4e,0x88,0x7b,0x4c};
+    memcpy(datafield+sizeof(reader_group_head)+sizeof(reader_group_id)+sizeof(reader_group_sub_id)+sizeof(endp_ePKX_h)+32+sizeof(reader_ePKX_h)+32+sizeof(transaction_id_head)+sizeof(transaction_id),endp_usage,sizeof(endp_usage));
+    
+    import_ecdsa_pub_key();
+    if(0==verify_endp_message(m_decrypted_text+69,64))
+    {
+        LockStateChangebyNfc();
+    }
+//auth1_have_done=true;
+   // crypto_finish();
+	return 0;
+}   
+
+void Make_control_flow_cmd()
+{
+    psa_status_t status;
+    uint8_t control_flow_cmd[]={0x80,0x3c,0x40,0xa0};
+    uint16_t   *rxLen;
+    uint8_t    *rxData;
+    ReturnCode err;
+	if(device_credential_key_added == true)
+	{
+		control_flow_cmd[2]=0x01;
+		control_flow_cmd[3]=0x00;	
+	}
+     /* Exchange APDU: Unified Access APDUs */
+    err = demoTransceiveBlocking( control_flow_cmd, sizeof(control_flow_cmd), &rxData, &rxLen, RFAL_FWT_NONE );
+    if( (err == ERR_NONE)  && rxData[*rxLen-2] == 0x90 && rxData[*rxLen-1] == 0x00)
+    {
+        /* Here more APDUs to implement the protocol are required. */
+        LOG_INF("transaction sucess\n");
+
+    }else
+    {
+         LOG_INF("transaction fail\n");
+    }
+}
+
+void Make_ECPVASUP_cmd(uint8_t *data,size_t size)
+{
+	uint8_t temp[40];
+
+ 	read_from_flash(temp,40);
+    memcpy(reader_group_id,temp,sizeof(reader_group_id));
+    memcpy(reader_SK,temp+sizeof(reader_group_id),sizeof(reader_SK));
+	memcpy(data,demoEcpVasup,size);
+	memcpy(data+8,reader_group_id,sizeof(reader_group_id));
+}
+
+int make_select_cmd()
+{
+     ReturnCode err;
+    uint16_t   *rxLen;
+    uint8_t    *rxData;
+
+    err = demoTransceiveBlocking( expTransacSelectApp, sizeof(expTransacSelectApp), &rxData, &rxLen, RFAL_FWT_NONE );
+
+    if( (err == ERR_NONE) && (*rxLen > 2) && rxData[*rxLen-2] == 0x90 && rxData[*rxLen-1] == 0x00)
+    {
+        //memcpy(select_resp,rxData,*rxLen-2);
+
+        return 0;
+    }
+    else
+    {
+         LOG_INF("select fail\n");
+        return -1;
+    }
+}
+
+int make_exchange_cmd()
+{
+	uint8_t datafield[48]={0x00 ,0x8E ,0x22 ,0xC0 ,0x20 ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0xAA ,0x80 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00};
+	uint8_t iv_for_miv[16]={0};
+    uint8_t append_text[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01};
+    uint8_t m_iv[16];
+	uint8_t encryptedData[48]; 
+	memcpy(datafield+5,s_secret,sizeof(s_secret));
+	encrypt_cbc_aes(m_iv,sizeof(m_iv),append_text,sizeof(append_text),iv_for_miv);
+	encrypt_cbc_aes(encryptedData,sizeof(encryptedData),datafield,sizeof(datafield),m_iv);
+	uint8_t mac_chaining_in[]={0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00};
+	uint8_t plain_txt_for_cmaccal[48+16];
+	memcpy(plain_txt_for_cmaccal,mac_chaining_in,sizeof(mac_chaining_in));
+	memcpy(plain_txt_for_cmaccal+sizeof(mac_chaining_in),encryptedData,sizeof(encryptedData));
+    import_cmac_key(hkdf_output_key48+16);
+	uint8_t cmac[16];
+	cmac_sign(plain_txt_for_cmaccal ,sizeof(plain_txt_for_cmaccal),cmac ,sizeof(cmac));
+	uint8_t exchange_head[]={0x84,0xc9,0x00,0x00,0x38};
+	uint8_t exchange_end[]={0x00};
+	uint8_t exchange_cmd[5+48+16+1];
+	memcpy(exchange_cmd,exchange_head,sizeof(exchange_head));
+	memcpy(exchange_cmd+sizeof(exchange_head),encryptedData,sizeof(encryptedData)); 
+	memcpy(exchange_cmd+sizeof(exchange_head)+sizeof(encryptedData),cmac,sizeof(cmac)); 
+	memcpy(exchange_cmd+sizeof(exchange_head)+sizeof(encryptedData)+sizeof(cmac),exchange_end,sizeof(exchange_end)); 
+
+	ReturnCode err;
+	uint16_t   *rxLen;
+    uint8_t    *rxData;
+     /* Exchange APDU: Unified Access APDUs */
+    err = demoTransceiveBlocking( exchange_cmd, sizeof(exchange_cmd), &rxData, &rxLen, RFAL_FWT_NONE );
+    if( (err == ERR_NONE)  && rxData[*rxLen-2] == 0x90 && rxData[*rxLen-1] == 0x00)
+    {
+        /* Here more APDUs to implement the protocol are required. */
+        LOG_INF("exchange sucess\n");
+
+    }else
+    {
+         LOG_INF("transaction fail\n");
+    }
+	return 0;
+}
+int make_select_stepup_cmd()
+{
+     ReturnCode err;
+    uint16_t   *rxLen;
+    uint8_t    *rxData;
+	static uint8_t select_stepup[] = { 0x00, 0xA4, 0x04, 0x00, 0x07, 0xA0, 0x00, 0x00, 0x08, 0x58, 0x01, 0x02, 0x00};
+    err = demoTransceiveBlocking( select_stepup, sizeof(select_stepup), &rxData, &rxLen, RFAL_FWT_NONE );
+
+    if( (err == ERR_NONE)  && rxData[*rxLen-2] == 0x90 && rxData[*rxLen-1] == 0x00)
+    {
+        //memcpy(select_resp,rxData,*rxLen-2);
+		LOG_INF("stepup select suc\n");
+        return 0;
+    }
+    else
+    {
+         LOG_INF("select fail\n");
+        return -1;
+    }
+}
+static uint8_t handover_select[105];
+int make_conn_handover_cmd()
+{
+     ReturnCode err;
+    uint16_t   *rxLen;
+    uint8_t    *rxData;
+	static uint8_t handover_stepup[] = {0x00 ,0xC3 ,0x00 ,0x01 ,0x73 ,0x53 ,0x71 ,0x91 ,0x02 ,0x1E ,0x48 ,0x72 ,0x15 ,0x91 ,0x02 ,0x02 ,0x63 ,0x72 ,0x01 ,0x02 ,0x51 ,0x02 ,0x11 ,0x61 ,0x63 ,0x01 ,0x03 ,0x6E ,0x66 ,0x63 ,0x01 ,0x0A ,0x6D ,0x64 ,0x6F ,0x63 ,0x72 ,0x65 ,0x61 ,0x64 ,0x65 ,0x72 ,0x1C ,0x11 ,0x01 ,0x03 ,0x69 ,0x73 ,0x6F ,0x2E ,0x6F ,0x72 ,0x67 ,0x3A ,0x31 ,0x38 ,0x30 ,0x31 ,0x33 ,0x3A ,0x6E ,0x66 ,0x63 ,0x6E ,0x66 ,0x63 ,0x01 ,0x5C ,0x1E ,0x09 ,0x0A ,0x69 ,0x73 ,0x6F ,0x2E ,0x6F ,0x72 ,0x67 ,0x3A ,0x31 ,0x38 ,0x30 ,0x31 ,0x33 ,0x3A ,0x72 ,0x65 ,0x61 ,0x64 ,0x65 ,0x72 ,0x65 ,0x6E ,0x67 ,0x61 ,0x67 ,0x65 ,0x6D ,0x65 ,0x6E ,0x74 ,0x6D ,0x64 ,0x6F ,0x63 ,0x72 ,0x65 ,0x61 ,0x64 ,0x65 ,0x72 ,0xA2 ,0x00 ,0x63 ,0x31 ,0x2E ,0x30 ,0x20 ,0x81 ,0x29 ,0x00};
+    err = demoTransceiveBlocking( handover_stepup, sizeof(handover_stepup), &rxData, &rxLen, RFAL_FWT_NONE );
+
+    if( (err == ERR_NONE) && (*rxLen > 2) && rxData[*rxLen-2] == 0x90 && rxData[*rxLen-1] == 0x00)
+    {
+      
+		memcpy(handover_select,rxData,*rxLen-2);
+		LOG_INF("handover req suc\n");
+        return 0;
+    }
+    else
+    {
+         LOG_INF("handover req fail\n");
+        return -1;
+    }
+}
+
+static int import_hkdf_input_key_stepup(uint8_t *kdh)
+{
+	psa_status_t status;
+	psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
+
+	/* Configure the input key attributes */
+	psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_DERIVE);
+	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
+	psa_set_key_algorithm(&key_attributes, PSA_ALG_HKDF(PSA_ALG_SHA_256));
+	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_DERIVE);
+	psa_set_key_bits(&key_attributes,
+			 32 * 8);
+    //PRINT_HEX("kdhhkdf", kdh, 32);
+	/* Import the master key into the keystore */
+	status = psa_import_key(&key_attributes,
+				kdh,
+				32,
+				&hkdf_in_handle_stepup);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_import_key failed! (Error: %d)", status);
+		return -1;
+	}
+LOG_INF("import_hkdf_input_key successfully!");
+	return 0;
+}
+
+static int derive_hkdf_stepup(size_t out_key_size,uint8_t * m_ainfo , size_t info_len,uint8_t * m_salt,size_t salt_len)
+{
+	psa_status_t status;
+	psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
+	psa_key_derivation_operation_t operation =
+		PSA_KEY_DERIVATION_OPERATION_INIT;
+
+	LOG_INF("Deriving a key using HKDF and SHA256...");
+
+	/* Derived key settings
+	 * WARNING: This key usage makes the key exportable which is not safe and
+	 * is only done to demonstrate the validity of the results. Please do not use
+	 * this in production environments.
+	 */
+	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
+	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_RAW_DATA);
+	psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_EXPORT); /* DONT USE IN PRODUCTION */
+	psa_set_key_bits(&key_attributes, out_key_size * 8);
+
+	/* Set the derivation algorithm */
+	status = psa_key_derivation_setup(&operation,
+					  PSA_ALG_HKDF(PSA_ALG_SHA_256));
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_key_derivation_setup failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Set the salt for the operation */
+	status = psa_key_derivation_input_bytes(&operation,
+						PSA_KEY_DERIVATION_INPUT_SALT,
+						m_salt,
+						salt_len);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_key_derivation_input_bytes failed! (Error: %d)", status);
+		return -1;
+	}
+	/* Set the master key for the operation */
+	status = psa_key_derivation_input_key(
+		&operation, PSA_KEY_DERIVATION_INPUT_SECRET, hkdf_in_handle_stepup);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_key_derivation_input_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+    //PRINT_HEX("m_ainfo", m_ainfo, info_len);
+	/* Set the additional info for the operation */
+	status = psa_key_derivation_input_bytes(&operation,
+						PSA_KEY_DERIVATION_INPUT_INFO,
+						m_ainfo,
+						info_len);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_key_derivation_input_bytes failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Store the derived key in the keystore slot pointed by out_key_handle */
+	status = psa_key_derivation_output_key(&key_attributes, &operation, &hkdf_out_handle_stepup);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_key_derivation_output_key failed! (Error: %d)", status);
+		return -1;
+	}
+
+	/* Clean up the context */
+	status = psa_key_derivation_abort(&operation);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_key_derivation_abort failed! (Error: %d)", status);
+		return -1;
+	}
+
+	LOG_INF("stepup Key derivation successful!");
+
+	return 0;
+}
+
+int import_aesgcm_key(uint8_t * m_in_aesgcm_key, size_t key_size)
+{
+	psa_status_t status;
+
+	LOG_INF("import AES gcm key...");
+
+	/* Configure the key attributes */
+	psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
+
+	psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_ENCRYPT | PSA_KEY_USAGE_DECRYPT);
+	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
+	psa_set_key_algorithm(&key_attributes, PSA_ALG_GCM);
+	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_AES);
+	psa_set_key_bits(&key_attributes, 128);
+
+	/* Import the master key into the keystore */
+	status = psa_import_key(&key_attributes,
+				m_in_aesgcm_key,
+				key_size,
+				&aesgcm_key_handle);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_import_key failed! (Error: %d)", status);
+		return -1;
+	}
+	/* After the key handle is acquired the attributes are not needed */
+	psa_reset_key_attributes(&key_attributes);
+
+	LOG_INF("AES gcm key generated successfully!");
+
+	return 0;
+}
+int import_aesgcm_key_device(uint8_t * m_in_aesgcm_key, size_t key_size)
+{
+	psa_status_t status;
+
+	LOG_INF("import AES gcm key...");
+
+	/* Configure the key attributes */
+	psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
+
+	psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_ENCRYPT | PSA_KEY_USAGE_DECRYPT);
+	psa_set_key_lifetime(&key_attributes, PSA_KEY_LIFETIME_VOLATILE);
+	psa_set_key_algorithm(&key_attributes, PSA_ALG_GCM);
+	psa_set_key_type(&key_attributes, PSA_KEY_TYPE_AES);
+	psa_set_key_bits(&key_attributes, 128);
+
+	/* Import the master key into the keystore */
+	status = psa_import_key(&key_attributes,
+				m_in_aesgcm_key,
+				key_size,
+				&aesgcm_key_handle_device);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_import_key failed! (Error: %d)", status);
+		return -1;
+	}
+	/* After the key handle is acquired the attributes are not needed */
+	psa_reset_key_attributes(&key_attributes);
+
+	LOG_INF("AES gcm key generated successfully!");
+
+	return 0;
+}
+int make_data_tran_cmd()
+{
+    ReturnCode err;
+	psa_status_t status;
+    uint16_t   *rxLen;
+    uint8_t    *rxData;
+	    uint16_t   *rxLen1;
+    uint8_t    *rxData1;
+	    uint16_t   *rxLen2;
+    uint8_t    *rxData2;
+	    uint16_t   *rxLen3;
+    uint8_t    *rxData3;
+	//static uint8_t data_stepup[] = {0x00 ,0xc3 ,0x00 ,0x00 ,0xb7 ,0x53 ,0x81 ,0xb4 ,0xa1 ,0x64 ,0x64 ,0x61 ,0x74 ,0x61 ,0x58 ,0xac ,0x56 ,0xe2 ,0x5e ,0x16 ,0x79 ,0xc6 ,0x7b ,0x1a ,0xb5 ,0x6d ,0x54 ,0x5d ,0xf5 ,0xd4 ,0x2a ,0xcb ,0x53 ,0xab ,0xc3 ,0x6a ,0x81 ,0xbc ,0x0e ,0xeb ,0xa8 ,0xb3 ,0xf6 ,0x90 ,0x2e ,0x99 ,0x65 ,0xdd ,0x1b ,0xb6 ,0x32 ,0x59 ,0xe4 ,0xa8 ,0x39 ,0x3d ,0xaa ,0xfc ,0x3e ,0x70 ,0x61 ,0xb4 ,0x85 ,0x96 ,0x22 ,0x12 ,0x7d ,0x0c ,0xd5 ,0xe4 ,0x5b ,0xb5 ,0x10 ,0xe7 ,0x65 ,0xbe ,0x26 ,0x81 ,0xf6 ,0x2f ,0x05 ,0xda ,0xf1 ,0x30 ,0xea ,0x8f ,0xfb ,0xe5 ,0xe1 ,0xfe ,0x05 ,0xf9 ,0x04 ,0x3b ,0xab ,0xdc ,0xf9 ,0xe9 ,0xef ,0x46 ,0x8b ,0x36 ,0x8d ,0xb9 ,0x09 ,0x7e ,0x26 ,0xeb ,0xdc ,0x3d ,0xb2 ,0x74 ,0xf3 ,0xd7 ,0xbf ,0x17 ,0xc3 ,0xc0 ,0xbf ,0x8a ,0x40 ,0x3c ,0x73 ,0xec ,0x7a ,0xc0 ,0x19 ,0x43 ,0x4c ,0x87 ,0xac ,0x18 ,0xeb ,0xd5 ,0xc7 ,0x84 ,0xaf ,0xdc ,0xba ,0x50 ,0x87 ,0xad ,0xa6 ,0xd8 ,0x8d ,0x22 ,0x8d ,0x4c ,0x12 ,0xf1 ,0x08 ,0x20 ,0x9f ,0x1d ,0x80 ,0xf0 ,0x57 ,0xeb ,0x4b ,0x09 ,0x26 ,0xb8 ,0x01 ,0x52 ,0x80 ,0x36 ,0x51 ,0xed ,0xc5 ,0x78 ,0x54 ,0x63 ,0x9c ,0x4a ,0x0a ,0xcc ,0x42 ,0xd3 ,0x7c ,0x16 ,0xb6 ,0x8c ,0x59 ,0x92 ,0x3d ,0x93 ,0xc0 ,0x95 ,0x00};
+    uint8_t device_req[]={
+		0xa2 ,0x67 ,0x76 ,0x65 ,0x72 ,0x73 ,0x69 ,0x6f ,0x6e ,0x63 ,0x31 ,0x2e ,0x30 ,0x6b ,0x64 ,0x6f ,0x63 ,0x52 ,0x65 ,0x71 ,0x75 ,0x65 ,0x73 ,0x74 ,0x73 ,0x81 ,0xa1 ,0x6c ,0x69 ,0x74 ,0x65 ,0x6d ,0x73 ,0x52 ,0x65 ,0x71 ,0x75 ,0x65 ,0x73 ,0x74 ,0xd8 ,0x18 ,0x58 ,0x70 ,0xa2 ,0x67 ,0x64 ,0x6f ,0x63 ,0x54 ,0x79 ,0x70 ,0x65 ,0x78 ,0x1e ,0x63 ,0x6f ,0x6d ,0x2e ,0x61 ,0x70 ,0x70 ,0x6c ,0x65 ,0x2e ,0x48 ,0x6f ,0x6d ,0x65 ,0x4b ,0x69 ,0x74 ,0x2e ,0x31 ,0x2e ,0x63 ,0x72 ,0x65 ,0x64 ,0x65 ,0x6e ,0x74 ,0x69 ,0x61 ,0x6c ,0x6a ,0x6e ,0x61 ,0x6d ,0x65 ,0x53 ,0x70 ,0x61 ,0x63 ,0x65 ,0x73 ,0xa1 ,0x71 ,0x63 ,0x6f ,0x6d ,0x2e ,0x61 ,0x70 ,0x70 ,0x6c ,0x65 ,0x2e ,0x48 ,0x6f ,0x6d ,0x65 ,0x4b ,0x69 ,0x74 ,0xa2 ,0x6d ,0x63 ,0x72 ,0x65 ,0x64 ,0x65 ,0x6e ,0x74 ,0x69 ,0x61 ,0x6c ,0x5f ,0x69 ,0x64 ,0xf4 ,0x77 ,0x61 ,0x63 ,0x63 ,0x65 ,0x73 ,0x73 ,0x5f ,0x62 ,0x75 ,0x69 ,0x6c ,0x64 ,0x69 ,0x6e ,0x67 ,0x31 ,0x2e ,0x66 ,0x6c ,0x6f ,0x6f ,0x72 ,0x32 ,0xf4
+	};
+	 uint8_t device_req_encrepted[156+16];
+	uint8_t session_tranByte_forsalt[]={0xd8 ,0x18 ,0x58 ,0xe9 ,0x82 ,0xD8 ,0x18 ,0x49 ,0xA2 ,0x00 ,0x63 ,0x31 ,0x2E ,0x30 ,0x01 ,0x81 ,0x29 ,0x82 ,0x58 ,0x66 ,0x91 ,0x02 ,0x11 ,0x48 ,0x73 ,0x15 ,0xD1 ,0x02 ,0x0B ,0x61 ,0x63 ,0x01 ,0x03 ,0x6E ,0x66 ,0x63 ,0x01 ,0x04 ,0x6D ,0x64 ,0x6F ,0x63 ,0x1C ,0x11 ,0x09 ,0x03 ,0x69 ,0x73 ,0x6F ,0x2E ,0x6F ,0x72 ,0x67 ,0x3A ,0x31 ,0x38 ,0x30 ,0x31 ,0x33 ,0x3A ,0x6E ,0x66 ,0x63 ,0x6E ,0x66 ,0x63 ,0x01 ,0x03 ,0x01 ,0x10 ,0x00 ,0x03 ,0x02 ,0x10 ,0x00 ,0x5C ,0x1E ,0x09 ,0x04 ,0x69 ,0x73 ,0x6F ,0x2E ,0x6F ,0x72 ,0x67 ,0x3A ,0x31 ,0x38 ,0x30 ,0x31 ,0x33 ,0x3A ,0x64 ,0x65 ,0x76 ,0x69 ,0x63 ,0x65 ,0x65 ,0x6E ,0x67 ,0x61 ,0x67 ,0x65 ,0x6D ,0x65 ,0x6E ,0x74 ,0x6D ,0x64 ,0x6F ,0x63 ,0xA2 ,0x00 ,0x63 ,0x31 ,0x2E ,0x30 ,0x01 ,0x81 ,0x29 ,0x58 ,0x71 ,0x91 ,0x02 ,0x1E ,0x48 ,0x72 ,0x15 ,0x91 ,0x02 ,0x02 ,0x63 ,0x72 ,0x01 ,0x02 ,0x51 ,0x02 ,0x11 ,0x61 ,0x63 ,0x01 ,0x03 ,0x6E ,0x66 ,0x63 ,0x01 ,0x0A ,0x6D ,0x64 ,0x6F ,0x63 ,0x72 ,0x65 ,0x61 ,0x64 ,0x65 ,0x72 ,0x1C ,0x11 ,0x01 ,0x03 ,0x69 ,0x73 ,0x6F ,0x2E ,0x6F ,0x72 ,0x67 ,0x3A ,0x31 ,0x38 ,0x30 ,0x31 ,0x33 ,0x3A ,0x6E ,0x66 ,0x63 ,0x6E ,0x66 ,0x63 ,0x01 ,0x5C ,0x1E ,0x09 ,0x0A ,0x69 ,0x73 ,0x6F ,0x2E ,0x6F ,0x72 ,0x67 ,0x3A ,0x31 ,0x38 ,0x30 ,0x31 ,0x33 ,0x3A ,0x72 ,0x65 ,0x61 ,0x64 ,0x65 ,0x72 ,0x65 ,0x6E ,0x67 ,0x61 ,0x67 ,0x65 ,0x6D ,0x65 ,0x6E ,0x74 ,0x6D ,0x64 ,0x6F ,0x63 ,0x72 ,0x65 ,0x61 ,0x64 ,0x65 ,0x72 ,0xA2 ,0x00 ,0x63 ,0x31 ,0x2E ,0x30 ,0x20 ,0x81 ,0x29};
+    memcpy(session_tranByte_forsalt+20,handover_select+2,102);
+	uint8_t salt_stepup[32];
+	uint32_t output_len;
+	/* Compute the SHA256 hash*/
+	status = psa_hash_compute(PSA_ALG_SHA_256,
+				  session_tranByte_forsalt,
+				  sizeof(session_tranByte_forsalt),
+				  salt_stepup,
+				  sizeof(salt_stepup),
+				  &output_len);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_hash_compute failed! (Error: %d)", status);
+	}
+
+	import_hkdf_input_key_stepup(s_secret);
+	uint8_t m_ainfo_16[] = {0x53 ,0x4b ,0x52 ,0x65 ,0x61 ,0x64 ,0x65 ,0x72};
+	derive_hkdf_stepup(16,m_ainfo_16,sizeof(m_ainfo_16),salt_stepup,  sizeof(salt_stepup));
+	 size_t olen;
+	 uint8_t skreader_key[16];
+    /* Export the generated key content to verify it's value */
+	status = psa_export_key(hkdf_out_handle_stepup, skreader_key, sizeof(skreader_key), &olen);
+
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_export_key failed! (Error: %d)", status);
+		
+	}
+	uint8_t m_ainfo_16_device[] = {0x53 ,0x4b ,0x44 ,0x65 ,0x76 ,0x69 ,0x63 ,0x65};
+	derive_hkdf_stepup(16,m_ainfo_16_device,sizeof(m_ainfo_16_device),salt_stepup,  sizeof(salt_stepup));
+		
+	 uint8_t skdevice_key[16];
+    /* Export the generated key content to verify it's value */
+	status = psa_export_key(hkdf_out_handle_stepup, skdevice_key, sizeof(skdevice_key), &olen);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_export_key failed! (Error: %d)", status);
+		
+	}
+
+
+	//k_sleep(K_MSEC(10));
+	import_aesgcm_key(skreader_key,sizeof(skreader_key));
+	uint8_t m_iv_for_gcm[]={0x00 ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01};
+	status = psa_aead_encrypt(aesgcm_key_handle,
+				  PSA_ALG_GCM,
+				  m_iv_for_gcm,
+				  sizeof(m_iv_for_gcm),
+				  NULL,
+				 0,
+				  device_req,
+				  sizeof(device_req),
+				  device_req_encrepted,
+				  sizeof(device_req_encrepted),
+				  &output_len);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_aead_encrypt failed! (Error: %d)", status);
+		return -1;
+	}
+
+	uint8_t session_establishment_data[16+156+16+1];
+    uint8_t session_establishment_head[]={0x00 ,0xC3 ,0x00 ,0x00 ,0xB7 ,0x53 ,0x81 ,0xB4 ,0xA1 ,0x64 ,0x64 ,0x61 ,0x74 ,0x61 ,0x58 ,0xAC};
+	uint8_t session_establishment_end[]={0x00};
+	memcpy(session_establishment_data,session_establishment_head,sizeof(session_establishment_head));
+	memcpy(session_establishment_data+sizeof(session_establishment_head),device_req_encrepted,sizeof(device_req_encrepted));
+	memcpy(session_establishment_data+sizeof(session_establishment_head)+sizeof(device_req_encrepted),session_establishment_end,sizeof(session_establishment_end));
+	uint8_t session_cmd1[]={0x00,0xc0,0x00,0x00,0x00};
+	uint8_t session_data[255+255+255+255];
+	uint32_t session_data_num=0;
+	err = demoTransceiveBlocking( session_establishment_data, sizeof(session_establishment_data), &rxData, &rxLen, RFAL_FWT_NONE );
+
+    if( (err == ERR_NONE) && (*rxLen > 2) && rxData[*rxLen-2] == 0x61 && rxData[*rxLen-1] == 0x00 )
+    {
+        
+		//LOG_INF("datat req suc\n");
+		
+		//PRINT_HEX("datat", rxData, *rxLen);
+		memcpy(session_data,rxData+13,((*rxLen)-15));
+		session_data_num=(*rxLen)-15;
+		//LOG_INF("session_data_num %u %u\n",session_data_num,(*rxLen));
+		k_sleep(K_MSEC(10));
+		err = demoTransceiveBlocking( session_cmd1, sizeof(session_cmd1), &rxData1, &rxLen1, RFAL_FWT_NONE );
+		if( (err == ERR_NONE) && (*rxLen1 > 2) && rxData1[*rxLen1-2] == 0x61 && rxData1[*rxLen1-1] == 0x00 )
+		{
+			//PRINT_HEX("datat1", rxData1, *rxLen1);
+			memcpy(session_data+session_data_num,rxData1,*rxLen1-2);
+			session_data_num=session_data_num+(*rxLen1-2);
+			//LOG_INF("session_data_num %u %u\n",session_data_num,(*rxLen1));
+			k_sleep(K_MSEC(10));
+			err = demoTransceiveBlocking( session_cmd1, sizeof(session_cmd1), &rxData2, &rxLen2, RFAL_FWT_NONE );
+			if( (err == ERR_NONE) && (*rxLen2 > 2) && rxData2[*rxLen2-2] == 0x61 )
+			{
+				//PRINT_HEX("data2", rxData2, *rxLen2);
+				memcpy(session_data+session_data_num,rxData2,*rxLen2-2);
+				session_data_num=session_data_num+(*rxLen2-2);
+				session_cmd1[4]=rxData2[*rxLen2-1];
+				//LOG_INF("session_data_num %u %u\n",session_data_num,(*rxLen2));
+				k_sleep(K_MSEC(10));
+				err = demoTransceiveBlocking( session_cmd1, sizeof(session_cmd1), &rxData3, &rxLen3, RFAL_FWT_NONE );
+				if( (err == ERR_NONE) && (*rxLen3 > 2) && rxData3[*rxLen3-2] == 0x90 && rxData3[*rxLen3-1] == 0x00 )
+				{
+					PRINT_HEX("data3", rxData3, *rxLen3);
+					memcpy(session_data+session_data_num,rxData3,*rxLen3-2);
+					session_data_num=session_data_num+(*rxLen3-2);
+					LOG_INF("session_data_num %u ******%u\n",session_data_num,*rxLen3);
+				}else
+				{
+					 LOG_INF("datat req3 fail\n");
+					return -1;
+				}
+			}else
+			{
+				 LOG_INF("datat req2 fail\n");
+				return -1;
+			}
+		}else
+		{
+			 LOG_INF("datat req1 fail\n");
+			return -1;
+		}
+
+        //return 0;
+    }
+    else
+    {
+         LOG_INF("datat req fail\n");
+		  PRINT_HEX("datat", rxData, *rxLen);
+        return -1;
+    }
+	LOG_INF("decrept session data\n");
+#if 0
+	uint8_t m_ainfo_16_device[] = {0x53 ,0x4b ,0x44 ,0x65 ,0x76 ,0x69 ,0x63 ,0x65};
+	derive_hkdf_stepup(16,m_ainfo_16_device,sizeof(m_ainfo_16_device),salt_stepup,  sizeof(salt_stepup));
+		
+	 uint8_t skdevice_key[16];
+    /* Export the generated key content to verify it's value */
+	status = psa_export_key(hkdf_out_handle_stepup, skdevice_key, sizeof(skdevice_key), &olen);
+
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_export_key failed! (Error: %d)", status);
+		
+	}
+#endif
+	//k_sleep(K_MSEC(10));
+	import_aesgcm_key_device(skdevice_key,sizeof(skdevice_key));
+	uint8_t m_iv_for_gcm_device[]={0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x01 ,0x00 ,0x00 ,0x00 ,0x01};
+	uint8_t session_data_decrepted[255+255+255+255];
+		/* Decrypt and authenticate the encrypted data */
+	status = psa_aead_decrypt(aesgcm_key_handle_device,
+				  PSA_ALG_GCM,
+				  m_iv_for_gcm_device,
+				  sizeof(m_iv_for_gcm_device),
+				  NULL,
+				  0,
+				  session_data,
+				session_data_num,
+				  session_data_decrepted,
+				  sizeof(session_data_decrepted),
+				  &output_len);
+	if (status != PSA_SUCCESS) {
+		LOG_INF("psa_aead_decrypt failed! (Error: %d)", status);
+		return -1;
+	}
+	//PRINT_HEX("session_data_decrepted", session_data_decrepted, output_len);
+	uint16_t i,j,k,l;
+	uint8_t aim_string={0x64 ,0x65 ,0x76 ,0x69 ,0x63 ,0x65 ,0x4B ,0x65 ,0x79};
+	//uint8_t device_credential_key[64];
+	for(i=0;i<output_len;i++)
+	{
+	  if(session_data_decrepted[i]== 0x64 &&
+	     session_data_decrepted[i+1]== 0x65 && 
+		 session_data_decrepted[i+2]== 0x76 &&
+		 session_data_decrepted[i+3]== 0x69 &&
+		 session_data_decrepted[i+4]== 0x63 &&
+		 session_data_decrepted[i+5]== 0x65 &&
+		 session_data_decrepted[i+6]== 0x4b &&
+		 session_data_decrepted[i+7]== 0x65 &&
+		 session_data_decrepted[i+8]== 0x79 &&
+		 session_data_decrepted[i+9]!= 0x49 &&
+		 session_data_decrepted[i+10]!= 0x6e &&
+		 session_data_decrepted[i+11]!= 0x66 &&
+		 session_data_decrepted[i+12]!= 0x6f 
+		 )
+		 {
+				for(j=i;j<output_len;j++)
+				{
+					 if(session_data_decrepted[j]== 0x58 &&
+	     				session_data_decrepted[j+1]== 0x20  )
+						{
+							for(k=0;k<32;k++)
+							{
+								device_credential_key[k]=session_data_decrepted[j+2+k];
+							}
+							break;
+						}
+						
+
+				}
+				for(l=j+2;l<output_len;l++)
+				{
+					 if(session_data_decrepted[l]== 0x58 &&
+	     				session_data_decrepted[l+1]== 0x20  )
+						{
+							for(k=0;k<32;k++)
+							{
+								device_credential_key[k+32]=session_data_decrepted[l+2+k];
+							}
+							break;
+						}
+				}
+				break;
+		 }
+	}
+	PRINT_HEX("device_credential_key", device_credential_key, 64);
+	HAPPlatformNfcAccessDeviceCredentialKey device_key_data;
+	NfcAccessStatusCode statuscode;
+	device_key_data.issuerKeyIdentifier=issuekey_identifier;
+	device_key_data.key=device_credential_key;
+	device_key_data.state=1;
+	device_key_data.type=2;
+	device_key_data.keyNumBytes=64;
+	HAPPlatformNfcAccessDeviceCredentialKeyAdd(&device_key_data,&statuscode);
+	LockStateChangebyNfc();
+} 
+void uaap_transactions( void )
+{
+ int  err;
+    if(0 != make_select_cmd())
+    {
+		crypto_finish();
+        return;
+    }
+	k_sleep(K_MSEC(10));
+    if(0 != Make_AUTH0_cmd())
+    {
+		crypto_finish();
+        return;
+    }
+    k_sleep(K_MSEC(10));
+	if(crypotogram_matched == false)
+	{
+    	if(0 != Make_AUTH1_cmd())
+		{
+			crypto_finish();
+			return;
+		}
+	}
+
+	if(device_credential_key_added == false)
+	{
+		//k_sleep(K_MSEC(30));
+		make_exchange_cmd();
+		//k_sleep(K_MSEC(30));
+    	Make_control_flow_cmd();
+		//k_sleep(K_MSEC(30));
+		make_select_stepup_cmd();
+		k_sleep(K_MSEC(10));
+		make_conn_handover_cmd();
+		k_sleep(K_MSEC(10));
+		make_data_tran_cmd();
+	}
+	else
+	{
+		Make_control_flow_cmd();
+	}
+    crypto_finish();
+}
+
-- 
2.33.0.windows.2

